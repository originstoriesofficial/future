"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@fal-ai";
exports.ids = ["vendor-chunks/@fal-ai"];
exports.modules = {

/***/ "(rsc)/./node_modules/@fal-ai/client/package.json":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/package.json ***!
  \**************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@fal-ai/client","description":"The fal.ai client for JavaScript and TypeScript","version":"1.6.2","license":"MIT","repository":{"type":"git","url":"https://github.com/fal-ai/fal-js.git","directory":"libs/client"},"keywords":["fal","client","ai","ml","typescript"],"exports":{".":"./src/index.js","./endpoints":"./src/types/endpoints.js"},"typesVersions":{"*":{"endpoints":["src/types/endpoints.d.ts"]}},"main":"./src/index.js","types":"./src/index.d.ts","dependencies":{"@msgpack/msgpack":"^3.0.0-beta2","eventsource-parser":"^1.1.2","robot3":"^0.4.1"},"engines":{"node":">=18.0.0"},"type":"commonjs"}');

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/auth.js":
/*!*************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/auth.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TOKEN_EXPIRATION_SECONDS = void 0;\nexports.getTemporaryAuthToken = getTemporaryAuthToken;\nconst config_1 = __webpack_require__(/*! ./config */ \"(rsc)/./node_modules/@fal-ai/client/src/config.js\");\nconst request_1 = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/@fal-ai/client/src/request.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@fal-ai/client/src/utils.js\");\nexports.TOKEN_EXPIRATION_SECONDS = 120;\n/**\n * Get a token to connect to the realtime endpoint.\n */\nfunction getTemporaryAuthToken(app, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const appId = (0, utils_1.parseEndpointId)(app);\n        const token = yield (0, request_1.dispatchRequest)({\n            method: \"POST\",\n            targetUrl: `${(0, config_1.getRestApiUrl)()}/tokens/`,\n            config,\n            input: {\n                allowed_apps: [appId.alias],\n                token_expiration: exports.TOKEN_EXPIRATION_SECONDS,\n            },\n        });\n        // keep this in case the response was wrapped (old versions of the proxy do that)\n        // should be safe to remove in the future\n        if (typeof token !== \"string\" && token[\"detail\"]) {\n            return token[\"detail\"];\n        }\n        return token;\n    });\n}\n//# sourceMappingURL=auth.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL2F1dGguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQztBQUNoQyw2QkFBNkI7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsbUVBQVU7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMscUVBQVc7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQVM7QUFDakMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NlYW4vZnV0dXJlL25vZGVfbW9kdWxlcy9AZmFsLWFpL2NsaWVudC9zcmMvYXV0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UT0tFTl9FWFBJUkFUSU9OX1NFQ09ORFMgPSB2b2lkIDA7XG5leHBvcnRzLmdldFRlbXBvcmFyeUF1dGhUb2tlbiA9IGdldFRlbXBvcmFyeUF1dGhUb2tlbjtcbmNvbnN0IGNvbmZpZ18xID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuY29uc3QgcmVxdWVzdF8xID0gcmVxdWlyZShcIi4vcmVxdWVzdFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMuVE9LRU5fRVhQSVJBVElPTl9TRUNPTkRTID0gMTIwO1xuLyoqXG4gKiBHZXQgYSB0b2tlbiB0byBjb25uZWN0IHRvIHRoZSByZWFsdGltZSBlbmRwb2ludC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGVtcG9yYXJ5QXV0aFRva2VuKGFwcCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgYXBwSWQgPSAoMCwgdXRpbHNfMS5wYXJzZUVuZHBvaW50SWQpKGFwcCk7XG4gICAgICAgIGNvbnN0IHRva2VuID0geWllbGQgKDAsIHJlcXVlc3RfMS5kaXNwYXRjaFJlcXVlc3QpKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICB0YXJnZXRVcmw6IGAkeygwLCBjb25maWdfMS5nZXRSZXN0QXBpVXJsKSgpfS90b2tlbnMvYCxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgYWxsb3dlZF9hcHBzOiBbYXBwSWQuYWxpYXNdLFxuICAgICAgICAgICAgICAgIHRva2VuX2V4cGlyYXRpb246IGV4cG9ydHMuVE9LRU5fRVhQSVJBVElPTl9TRUNPTkRTLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGtlZXAgdGhpcyBpbiBjYXNlIHRoZSByZXNwb25zZSB3YXMgd3JhcHBlZCAob2xkIHZlcnNpb25zIG9mIHRoZSBwcm94eSBkbyB0aGF0KVxuICAgICAgICAvLyBzaG91bGQgYmUgc2FmZSB0byByZW1vdmUgaW4gdGhlIGZ1dHVyZVxuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSBcInN0cmluZ1wiICYmIHRva2VuW1wiZGV0YWlsXCJdKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5bXCJkZXRhaWxcIl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/auth.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/client.js":
/*!***************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/client.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createFalClient = createFalClient;\nconst config_1 = __webpack_require__(/*! ./config */ \"(rsc)/./node_modules/@fal-ai/client/src/config.js\");\nconst queue_1 = __webpack_require__(/*! ./queue */ \"(rsc)/./node_modules/@fal-ai/client/src/queue.js\");\nconst realtime_1 = __webpack_require__(/*! ./realtime */ \"(rsc)/./node_modules/@fal-ai/client/src/realtime.js\");\nconst request_1 = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/@fal-ai/client/src/request.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/@fal-ai/client/src/response.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(rsc)/./node_modules/@fal-ai/client/src/storage.js\");\nconst streaming_1 = __webpack_require__(/*! ./streaming */ \"(rsc)/./node_modules/@fal-ai/client/src/streaming.js\");\n/**\n * Creates a new reference of the `FalClient`.\n * @param userConfig Optional configuration to override the default settings.\n * @returns a new instance of the `FalClient`.\n */\nfunction createFalClient(userConfig = {}) {\n    const config = (0, config_1.createConfig)(userConfig);\n    const storage = (0, storage_1.createStorageClient)({ config });\n    const queue = (0, queue_1.createQueueClient)({ config, storage });\n    const streaming = (0, streaming_1.createStreamingClient)({ config, storage });\n    const realtime = (0, realtime_1.createRealtimeClient)({ config });\n    return {\n        queue,\n        realtime,\n        storage,\n        streaming,\n        stream: streaming.stream,\n        run(endpointId_1) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, options = {}) {\n                const input = options.input\n                    ? yield storage.transformInput(options.input)\n                    : undefined;\n                return (0, request_1.dispatchRequest)({\n                    method: options.method,\n                    targetUrl: (0, request_1.buildUrl)(endpointId, options),\n                    input: input,\n                    config: Object.assign(Object.assign({}, config), { responseHandler: response_1.resultResponseHandler }),\n                    options: {\n                        signal: options.abortSignal,\n                        retry: {\n                            maxRetries: 3,\n                            baseDelay: 500,\n                            maxDelay: 15000,\n                        },\n                    },\n                });\n            });\n        },\n        subscribe: (endpointId, options) => __awaiter(this, void 0, void 0, function* () {\n            const { request_id: requestId } = yield queue.submit(endpointId, options);\n            if (options.onEnqueue) {\n                options.onEnqueue(requestId);\n            }\n            yield queue.subscribeToStatus(endpointId, Object.assign({ requestId }, options));\n            return queue.result(endpointId, { requestId });\n        }),\n    };\n}\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGlCQUFpQixtQkFBTyxDQUFDLG1FQUFVO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLGlFQUFTO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFZO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFXO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFZO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFXO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLHlFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSx5REFBeUQsUUFBUTtBQUNqRSxtREFBbUQsaUJBQWlCO0FBQ3BFLCtEQUErRCxpQkFBaUI7QUFDaEYsNERBQTRELFFBQVE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYSxtREFBbUQ7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFdBQVc7QUFDakYsOENBQThDLFdBQVc7QUFDekQsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NlYW4vZnV0dXJlL25vZGVfbW9kdWxlcy9AZmFsLWFpL2NsaWVudC9zcmMvY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUZhbENsaWVudCA9IGNyZWF0ZUZhbENsaWVudDtcbmNvbnN0IGNvbmZpZ18xID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuY29uc3QgcXVldWVfMSA9IHJlcXVpcmUoXCIuL3F1ZXVlXCIpO1xuY29uc3QgcmVhbHRpbWVfMSA9IHJlcXVpcmUoXCIuL3JlYWx0aW1lXCIpO1xuY29uc3QgcmVxdWVzdF8xID0gcmVxdWlyZShcIi4vcmVxdWVzdFwiKTtcbmNvbnN0IHJlc3BvbnNlXzEgPSByZXF1aXJlKFwiLi9yZXNwb25zZVwiKTtcbmNvbnN0IHN0b3JhZ2VfMSA9IHJlcXVpcmUoXCIuL3N0b3JhZ2VcIik7XG5jb25zdCBzdHJlYW1pbmdfMSA9IHJlcXVpcmUoXCIuL3N0cmVhbWluZ1wiKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWZlcmVuY2Ugb2YgdGhlIGBGYWxDbGllbnRgLlxuICogQHBhcmFtIHVzZXJDb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBzZXR0aW5ncy5cbiAqIEByZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgRmFsQ2xpZW50YC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmFsQ2xpZW50KHVzZXJDb25maWcgPSB7fSkge1xuICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfMS5jcmVhdGVDb25maWcpKHVzZXJDb25maWcpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSAoMCwgc3RvcmFnZV8xLmNyZWF0ZVN0b3JhZ2VDbGllbnQpKHsgY29uZmlnIH0pO1xuICAgIGNvbnN0IHF1ZXVlID0gKDAsIHF1ZXVlXzEuY3JlYXRlUXVldWVDbGllbnQpKHsgY29uZmlnLCBzdG9yYWdlIH0pO1xuICAgIGNvbnN0IHN0cmVhbWluZyA9ICgwLCBzdHJlYW1pbmdfMS5jcmVhdGVTdHJlYW1pbmdDbGllbnQpKHsgY29uZmlnLCBzdG9yYWdlIH0pO1xuICAgIGNvbnN0IHJlYWx0aW1lID0gKDAsIHJlYWx0aW1lXzEuY3JlYXRlUmVhbHRpbWVDbGllbnQpKHsgY29uZmlnIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHF1ZXVlLFxuICAgICAgICByZWFsdGltZSxcbiAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgc3RyZWFtaW5nLFxuICAgICAgICBzdHJlYW06IHN0cmVhbWluZy5zdHJlYW0sXG4gICAgICAgIHJ1bihlbmRwb2ludElkXzEpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAoZW5kcG9pbnRJZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBvcHRpb25zLmlucHV0XG4gICAgICAgICAgICAgICAgICAgID8geWllbGQgc3RvcmFnZS50cmFuc2Zvcm1JbnB1dChvcHRpb25zLmlucHV0KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHJlcXVlc3RfMS5kaXNwYXRjaFJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXJsOiAoMCwgcmVxdWVzdF8xLmJ1aWxkVXJsKShlbmRwb2ludElkLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwgeyByZXNwb25zZUhhbmRsZXI6IHJlc3BvbnNlXzEucmVzdWx0UmVzcG9uc2VIYW5kbGVyIH0pLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZURlbGF5OiA1MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVsYXk6IDE1MDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzdWJzY3JpYmU6IChlbmRwb2ludElkLCBvcHRpb25zKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlcXVlc3RfaWQ6IHJlcXVlc3RJZCB9ID0geWllbGQgcXVldWUuc3VibWl0KGVuZHBvaW50SWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25FbnF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVucXVldWUocmVxdWVzdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHF1ZXVlLnN1YnNjcmliZVRvU3RhdHVzKGVuZHBvaW50SWQsIE9iamVjdC5hc3NpZ24oeyByZXF1ZXN0SWQgfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXVlLnJlc3VsdChlbmRwb2ludElkLCB7IHJlcXVlc3RJZCB9KTtcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/config.js":
/*!***************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/config.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.credentialsFromEnv = void 0;\nexports.resolveDefaultFetch = resolveDefaultFetch;\nexports.createConfig = createConfig;\nexports.getRestApiUrl = getRestApiUrl;\nconst middleware_1 = __webpack_require__(/*! ./middleware */ \"(rsc)/./node_modules/@fal-ai/client/src/middleware.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/@fal-ai/client/src/response.js\");\nconst retry_1 = __webpack_require__(/*! ./retry */ \"(rsc)/./node_modules/@fal-ai/client/src/retry.js\");\nconst runtime_1 = __webpack_require__(/*! ./runtime */ \"(rsc)/./node_modules/@fal-ai/client/src/runtime.js\");\nfunction resolveDefaultFetch() {\n    if (typeof fetch === \"undefined\") {\n        throw new Error(\"Your environment does not support fetch. Please provide your own fetch implementation.\");\n    }\n    return fetch;\n}\n/**\n * Checks if the required FAL environment variables are set.\n *\n * @returns `true` if the required environment variables are set,\n * `false` otherwise.\n */\nfunction hasEnvVariables() {\n    return (typeof process !== \"undefined\" &&\n        process.env &&\n        (typeof process.env.FAL_KEY !== \"undefined\" ||\n            (typeof process.env.FAL_KEY_ID !== \"undefined\" &&\n                typeof process.env.FAL_KEY_SECRET !== \"undefined\")));\n}\nconst credentialsFromEnv = () => {\n    if (!hasEnvVariables()) {\n        return undefined;\n    }\n    if (typeof process.env.FAL_KEY !== \"undefined\") {\n        return process.env.FAL_KEY;\n    }\n    return process.env.FAL_KEY_ID\n        ? `${process.env.FAL_KEY_ID}:${process.env.FAL_KEY_SECRET}`\n        : undefined;\n};\nexports.credentialsFromEnv = credentialsFromEnv;\nconst DEFAULT_CONFIG = {\n    credentials: exports.credentialsFromEnv,\n    suppressLocalCredentialsWarning: false,\n    requestMiddleware: (request) => Promise.resolve(request),\n    responseHandler: response_1.defaultResponseHandler,\n    retry: retry_1.DEFAULT_RETRY_OPTIONS,\n};\n/**\n * Configures the fal client.\n *\n * @param config the new configuration.\n */\nfunction createConfig(config) {\n    var _a;\n    let configuration = Object.assign(Object.assign(Object.assign({}, DEFAULT_CONFIG), config), { fetch: (_a = config.fetch) !== null && _a !== void 0 ? _a : resolveDefaultFetch(), \n        // Merge retry configuration with defaults\n        retry: Object.assign(Object.assign({}, retry_1.DEFAULT_RETRY_OPTIONS), (config.retry || {})) });\n    if (config.proxyUrl) {\n        configuration = Object.assign(Object.assign({}, configuration), { requestMiddleware: (0, middleware_1.withMiddleware)(configuration.requestMiddleware, (0, middleware_1.withProxy)({ targetUrl: config.proxyUrl })) });\n    }\n    const { credentials: resolveCredentials, suppressLocalCredentialsWarning } = configuration;\n    const credentials = typeof resolveCredentials === \"function\"\n        ? resolveCredentials()\n        : resolveCredentials;\n    if ((0, runtime_1.isBrowser)() && credentials && !suppressLocalCredentialsWarning) {\n        console.warn(\"The fal credentials are exposed in the browser's environment. \" +\n            \"That's not recommended for production use cases.\");\n    }\n    return configuration;\n}\n/**\n * @returns the URL of the fal REST api endpoint.\n */\nfunction getRestApiUrl() {\n    return \"https://rest.alpha.fal.ai\";\n}\n//# sourceMappingURL=config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL2NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIscUJBQXFCLG1CQUFPLENBQUMsMkVBQWM7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsdUVBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQVM7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMscUVBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUIsR0FBRywyQkFBMkI7QUFDbEU7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLDhCQUE4QjtBQUNsRztBQUNBLDZDQUE2QyxxREFBcUQsSUFBSTtBQUN0RztBQUNBLHNEQUFzRCxvQkFBb0IsbUhBQW1ILDRCQUE0QixJQUFJO0FBQzdOO0FBQ0EsWUFBWSxtRUFBbUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zZWFuL2Z1dHVyZS9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL2NvbmZpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlZGVudGlhbHNGcm9tRW52ID0gdm9pZCAwO1xuZXhwb3J0cy5yZXNvbHZlRGVmYXVsdEZldGNoID0gcmVzb2x2ZURlZmF1bHRGZXRjaDtcbmV4cG9ydHMuY3JlYXRlQ29uZmlnID0gY3JlYXRlQ29uZmlnO1xuZXhwb3J0cy5nZXRSZXN0QXBpVXJsID0gZ2V0UmVzdEFwaVVybDtcbmNvbnN0IG1pZGRsZXdhcmVfMSA9IHJlcXVpcmUoXCIuL21pZGRsZXdhcmVcIik7XG5jb25zdCByZXNwb25zZV8xID0gcmVxdWlyZShcIi4vcmVzcG9uc2VcIik7XG5jb25zdCByZXRyeV8xID0gcmVxdWlyZShcIi4vcmV0cnlcIik7XG5jb25zdCBydW50aW1lXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuZnVuY3Rpb24gcmVzb2x2ZURlZmF1bHRGZXRjaCgpIHtcbiAgICBpZiAodHlwZW9mIGZldGNoID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdXIgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBmZXRjaC4gUGxlYXNlIHByb3ZpZGUgeW91ciBvd24gZmV0Y2ggaW1wbGVtZW50YXRpb24uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2g7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcmVxdWlyZWQgRkFMIGVudmlyb25tZW50IHZhcmlhYmxlcyBhcmUgc2V0LlxuICpcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVxdWlyZWQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGFyZSBzZXQsXG4gKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaGFzRW52VmFyaWFibGVzKCkge1xuICAgIHJldHVybiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYgJiZcbiAgICAgICAgKHR5cGVvZiBwcm9jZXNzLmVudi5GQUxfS0VZICE9PSBcInVuZGVmaW5lZFwiIHx8XG4gICAgICAgICAgICAodHlwZW9mIHByb2Nlc3MuZW52LkZBTF9LRVlfSUQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgcHJvY2Vzcy5lbnYuRkFMX0tFWV9TRUNSRVQgIT09IFwidW5kZWZpbmVkXCIpKSk7XG59XG5jb25zdCBjcmVkZW50aWFsc0Zyb21FbnYgPSAoKSA9PiB7XG4gICAgaWYgKCFoYXNFbnZWYXJpYWJsZXMoKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MuZW52LkZBTF9LRVkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52LkZBTF9LRVk7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLmVudi5GQUxfS0VZX0lEXG4gICAgICAgID8gYCR7cHJvY2Vzcy5lbnYuRkFMX0tFWV9JRH06JHtwcm9jZXNzLmVudi5GQUxfS0VZX1NFQ1JFVH1gXG4gICAgICAgIDogdW5kZWZpbmVkO1xufTtcbmV4cG9ydHMuY3JlZGVudGlhbHNGcm9tRW52ID0gY3JlZGVudGlhbHNGcm9tRW52O1xuY29uc3QgREVGQVVMVF9DT05GSUcgPSB7XG4gICAgY3JlZGVudGlhbHM6IGV4cG9ydHMuY3JlZGVudGlhbHNGcm9tRW52LFxuICAgIHN1cHByZXNzTG9jYWxDcmVkZW50aWFsc1dhcm5pbmc6IGZhbHNlLFxuICAgIHJlcXVlc3RNaWRkbGV3YXJlOiAocmVxdWVzdCkgPT4gUHJvbWlzZS5yZXNvbHZlKHJlcXVlc3QpLFxuICAgIHJlc3BvbnNlSGFuZGxlcjogcmVzcG9uc2VfMS5kZWZhdWx0UmVzcG9uc2VIYW5kbGVyLFxuICAgIHJldHJ5OiByZXRyeV8xLkRFRkFVTFRfUkVUUllfT1BUSU9OUyxcbn07XG4vKipcbiAqIENvbmZpZ3VyZXMgdGhlIGZhbCBjbGllbnQuXG4gKlxuICogQHBhcmFtIGNvbmZpZyB0aGUgbmV3IGNvbmZpZ3VyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGNvbmZpZ3VyYXRpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9DT05GSUcpLCBjb25maWcpLCB7IGZldGNoOiAoX2EgPSBjb25maWcuZmV0Y2gpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlc29sdmVEZWZhdWx0RmV0Y2goKSwgXG4gICAgICAgIC8vIE1lcmdlIHJldHJ5IGNvbmZpZ3VyYXRpb24gd2l0aCBkZWZhdWx0c1xuICAgICAgICByZXRyeTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXRyeV8xLkRFRkFVTFRfUkVUUllfT1BUSU9OUyksIChjb25maWcucmV0cnkgfHwge30pKSB9KTtcbiAgICBpZiAoY29uZmlnLnByb3h5VXJsKSB7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZ3VyYXRpb24pLCB7IHJlcXVlc3RNaWRkbGV3YXJlOiAoMCwgbWlkZGxld2FyZV8xLndpdGhNaWRkbGV3YXJlKShjb25maWd1cmF0aW9uLnJlcXVlc3RNaWRkbGV3YXJlLCAoMCwgbWlkZGxld2FyZV8xLndpdGhQcm94eSkoeyB0YXJnZXRVcmw6IGNvbmZpZy5wcm94eVVybCB9KSkgfSk7XG4gICAgfVxuICAgIGNvbnN0IHsgY3JlZGVudGlhbHM6IHJlc29sdmVDcmVkZW50aWFscywgc3VwcHJlc3NMb2NhbENyZWRlbnRpYWxzV2FybmluZyB9ID0gY29uZmlndXJhdGlvbjtcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IHR5cGVvZiByZXNvbHZlQ3JlZGVudGlhbHMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IHJlc29sdmVDcmVkZW50aWFscygpXG4gICAgICAgIDogcmVzb2x2ZUNyZWRlbnRpYWxzO1xuICAgIGlmICgoMCwgcnVudGltZV8xLmlzQnJvd3NlcikoKSAmJiBjcmVkZW50aWFscyAmJiAhc3VwcHJlc3NMb2NhbENyZWRlbnRpYWxzV2FybmluZykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgZmFsIGNyZWRlbnRpYWxzIGFyZSBleHBvc2VkIGluIHRoZSBicm93c2VyJ3MgZW52aXJvbm1lbnQuIFwiICtcbiAgICAgICAgICAgIFwiVGhhdCdzIG5vdCByZWNvbW1lbmRlZCBmb3IgcHJvZHVjdGlvbiB1c2UgY2FzZXMuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlndXJhdGlvbjtcbn1cbi8qKlxuICogQHJldHVybnMgdGhlIFVSTCBvZiB0aGUgZmFsIFJFU1QgYXBpIGVuZHBvaW50LlxuICovXG5mdW5jdGlvbiBnZXRSZXN0QXBpVXJsKCkge1xuICAgIHJldHVybiBcImh0dHBzOi8vcmVzdC5hbHBoYS5mYWwuYWlcIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fal = exports.parseEndpointId = exports.isRetryableError = exports.ValidationError = exports.ApiError = exports.withProxy = exports.withMiddleware = exports.createFalClient = void 0;\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/@fal-ai/client/src/client.js\");\nvar client_2 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/@fal-ai/client/src/client.js\");\nObject.defineProperty(exports, \"createFalClient\", ({ enumerable: true, get: function () { return client_2.createFalClient; } }));\nvar middleware_1 = __webpack_require__(/*! ./middleware */ \"(rsc)/./node_modules/@fal-ai/client/src/middleware.js\");\nObject.defineProperty(exports, \"withMiddleware\", ({ enumerable: true, get: function () { return middleware_1.withMiddleware; } }));\nObject.defineProperty(exports, \"withProxy\", ({ enumerable: true, get: function () { return middleware_1.withProxy; } }));\nvar response_1 = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/@fal-ai/client/src/response.js\");\nObject.defineProperty(exports, \"ApiError\", ({ enumerable: true, get: function () { return response_1.ApiError; } }));\nObject.defineProperty(exports, \"ValidationError\", ({ enumerable: true, get: function () { return response_1.ValidationError; } }));\nvar retry_1 = __webpack_require__(/*! ./retry */ \"(rsc)/./node_modules/@fal-ai/client/src/retry.js\");\nObject.defineProperty(exports, \"isRetryableError\", ({ enumerable: true, get: function () { return retry_1.isRetryableError; } }));\n__exportStar(__webpack_require__(/*! ./types/common */ \"(rsc)/./node_modules/@fal-ai/client/src/types/common.js\"), exports);\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@fal-ai/client/src/utils.js\");\nObject.defineProperty(exports, \"parseEndpointId\", ({ enumerable: true, get: function () { return utils_1.parseEndpointId; } }));\n/**\n * Creates a singleton instance of the client. This is useful as a compatibility\n * layer for existing code that uses the clients version prior to 1.0.0.\n */\nexports.fal = (function createSingletonFalClient() {\n    let currentInstance = (0, client_1.createFalClient)();\n    return {\n        config(config) {\n            currentInstance = (0, client_1.createFalClient)(config);\n        },\n        get queue() {\n            return currentInstance.queue;\n        },\n        get realtime() {\n            return currentInstance.realtime;\n        },\n        get storage() {\n            return currentInstance.storage;\n        },\n        get streaming() {\n            return currentInstance.streaming;\n        },\n        run(id, options) {\n            return currentInstance.run(id, options);\n        },\n        subscribe(endpointId, options) {\n            return currentInstance.subscribe(endpointId, options);\n        },\n        stream(endpointId, options) {\n            return currentInstance.stream(endpointId, options);\n        },\n    };\n})();\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRyx1QkFBdUIsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUI7QUFDcEwsaUJBQWlCLG1CQUFPLENBQUMsbUVBQVU7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLG1FQUFVO0FBQ2pDLG1EQUFrRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM5SCxtQkFBbUIsbUJBQU8sQ0FBQywyRUFBYztBQUN6QyxrREFBaUQsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDaEksNkNBQTRDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3RILGlCQUFpQixtQkFBTyxDQUFDLHVFQUFZO0FBQ3JDLDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCxtREFBa0QsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDaEksY0FBYyxtQkFBTyxDQUFDLGlFQUFTO0FBQy9CLG9EQUFtRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMvSCxhQUFhLG1CQUFPLENBQUMsK0VBQWdCO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxpRUFBUztBQUMvQixtREFBa0QsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsiL1VzZXJzL3NlYW4vZnV0dXJlL25vZGVfbW9kdWxlcy9AZmFsLWFpL2NsaWVudC9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmFsID0gZXhwb3J0cy5wYXJzZUVuZHBvaW50SWQgPSBleHBvcnRzLmlzUmV0cnlhYmxlRXJyb3IgPSBleHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGV4cG9ydHMuQXBpRXJyb3IgPSBleHBvcnRzLndpdGhQcm94eSA9IGV4cG9ydHMud2l0aE1pZGRsZXdhcmUgPSBleHBvcnRzLmNyZWF0ZUZhbENsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGNsaWVudF8xID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xudmFyIGNsaWVudF8yID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlRmFsQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfMi5jcmVhdGVGYWxDbGllbnQ7IH0gfSk7XG52YXIgbWlkZGxld2FyZV8xID0gcmVxdWlyZShcIi4vbWlkZGxld2FyZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndpdGhNaWRkbGV3YXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtaWRkbGV3YXJlXzEud2l0aE1pZGRsZXdhcmU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3aXRoUHJveHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pZGRsZXdhcmVfMS53aXRoUHJveHk7IH0gfSk7XG52YXIgcmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL3Jlc3BvbnNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXBpRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3BvbnNlXzEuQXBpRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWxpZGF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3BvbnNlXzEuVmFsaWRhdGlvbkVycm9yOyB9IH0pO1xudmFyIHJldHJ5XzEgPSByZXF1aXJlKFwiLi9yZXRyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUmV0cnlhYmxlRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHJ5XzEuaXNSZXRyeWFibGVFcnJvcjsgfSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9jb21tb25cIiksIGV4cG9ydHMpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlRW5kcG9pbnRJZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5wYXJzZUVuZHBvaW50SWQ7IH0gfSk7XG4vKipcbiAqIENyZWF0ZXMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIGNsaWVudC4gVGhpcyBpcyB1c2VmdWwgYXMgYSBjb21wYXRpYmlsaXR5XG4gKiBsYXllciBmb3IgZXhpc3RpbmcgY29kZSB0aGF0IHVzZXMgdGhlIGNsaWVudHMgdmVyc2lvbiBwcmlvciB0byAxLjAuMC5cbiAqL1xuZXhwb3J0cy5mYWwgPSAoZnVuY3Rpb24gY3JlYXRlU2luZ2xldG9uRmFsQ2xpZW50KCkge1xuICAgIGxldCBjdXJyZW50SW5zdGFuY2UgPSAoMCwgY2xpZW50XzEuY3JlYXRlRmFsQ2xpZW50KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9ICgwLCBjbGllbnRfMS5jcmVhdGVGYWxDbGllbnQpKGNvbmZpZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBxdWV1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2UucXVldWU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCByZWFsdGltZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2UucmVhbHRpbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZS5zdG9yYWdlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc3RyZWFtaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZS5zdHJlYW1pbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bihpZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZS5ydW4oaWQsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBzdWJzY3JpYmUoZW5kcG9pbnRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZS5zdWJzY3JpYmUoZW5kcG9pbnRJZCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmVhbShlbmRwb2ludElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEluc3RhbmNlLnN0cmVhbShlbmRwb2ludElkLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICB9O1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/middleware.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/middleware.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TARGET_URL_HEADER = void 0;\nexports.withMiddleware = withMiddleware;\nexports.withProxy = withProxy;\n/**\n * Setup a execution chain of middleware functions.\n *\n * @param middlewares one or more middleware functions.\n * @returns a middleware function that executes the given middlewares in order.\n */\nfunction withMiddleware(...middlewares) {\n    const isDefined = (middleware) => typeof middleware === \"function\";\n    return (config) => __awaiter(this, void 0, void 0, function* () {\n        let currentConfig = Object.assign({}, config);\n        for (const middleware of middlewares.filter(isDefined)) {\n            currentConfig = yield middleware(currentConfig);\n        }\n        return currentConfig;\n    });\n}\nexports.TARGET_URL_HEADER = \"x-fal-target-url\";\nfunction withProxy(config) {\n    const passthrough = (requestConfig) => Promise.resolve(requestConfig);\n    // when running on the server, we don't need to proxy the request\n    if (typeof window === \"undefined\") {\n        return passthrough;\n    }\n    // if x-fal-target-url is already set, we skip it\n    return (requestConfig) => requestConfig.headers && exports.TARGET_URL_HEADER in requestConfig\n        ? passthrough(requestConfig)\n        : Promise.resolve(Object.assign(Object.assign({}, requestConfig), { url: config.targetUrl, headers: Object.assign(Object.assign({}, (requestConfig.headers || {})), { [exports.TARGET_URL_HEADER]: requestConfig.url }) }));\n}\n//# sourceMappingURL=middleware.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL21pZGRsZXdhcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsb0JBQW9CLDhEQUE4RCw4QkFBOEIsTUFBTSxnREFBZ0QsR0FBRztBQUNqTztBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2Vhbi9mdXR1cmUvbm9kZV9tb2R1bGVzL0BmYWwtYWkvY2xpZW50L3NyYy9taWRkbGV3YXJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRBUkdFVF9VUkxfSEVBREVSID0gdm9pZCAwO1xuZXhwb3J0cy53aXRoTWlkZGxld2FyZSA9IHdpdGhNaWRkbGV3YXJlO1xuZXhwb3J0cy53aXRoUHJveHkgPSB3aXRoUHJveHk7XG4vKipcbiAqIFNldHVwIGEgZXhlY3V0aW9uIGNoYWluIG9mIG1pZGRsZXdhcmUgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSBtaWRkbGV3YXJlcyBvbmUgb3IgbW9yZSBtaWRkbGV3YXJlIGZ1bmN0aW9ucy5cbiAqIEByZXR1cm5zIGEgbWlkZGxld2FyZSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHRoZSBnaXZlbiBtaWRkbGV3YXJlcyBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gd2l0aE1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZXMpIHtcbiAgICBjb25zdCBpc0RlZmluZWQgPSAobWlkZGxld2FyZSkgPT4gdHlwZW9mIG1pZGRsZXdhcmUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICByZXR1cm4gKGNvbmZpZykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsZXQgY3VycmVudENvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XG4gICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiBtaWRkbGV3YXJlcy5maWx0ZXIoaXNEZWZpbmVkKSkge1xuICAgICAgICAgICAgY3VycmVudENvbmZpZyA9IHlpZWxkIG1pZGRsZXdhcmUoY3VycmVudENvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDb25maWc7XG4gICAgfSk7XG59XG5leHBvcnRzLlRBUkdFVF9VUkxfSEVBREVSID0gXCJ4LWZhbC10YXJnZXQtdXJsXCI7XG5mdW5jdGlvbiB3aXRoUHJveHkoY29uZmlnKSB7XG4gICAgY29uc3QgcGFzc3Rocm91Z2ggPSAocmVxdWVzdENvbmZpZykgPT4gUHJvbWlzZS5yZXNvbHZlKHJlcXVlc3RDb25maWcpO1xuICAgIC8vIHdoZW4gcnVubmluZyBvbiB0aGUgc2VydmVyLCB3ZSBkb24ndCBuZWVkIHRvIHByb3h5IHRoZSByZXF1ZXN0XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhc3N0aHJvdWdoO1xuICAgIH1cbiAgICAvLyBpZiB4LWZhbC10YXJnZXQtdXJsIGlzIGFscmVhZHkgc2V0LCB3ZSBza2lwIGl0XG4gICAgcmV0dXJuIChyZXF1ZXN0Q29uZmlnKSA9PiByZXF1ZXN0Q29uZmlnLmhlYWRlcnMgJiYgZXhwb3J0cy5UQVJHRVRfVVJMX0hFQURFUiBpbiByZXF1ZXN0Q29uZmlnXG4gICAgICAgID8gcGFzc3Rocm91Z2gocmVxdWVzdENvbmZpZylcbiAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0Q29uZmlnKSwgeyB1cmw6IGNvbmZpZy50YXJnZXRVcmwsIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlcXVlc3RDb25maWcuaGVhZGVycyB8fCB7fSkpLCB7IFtleHBvcnRzLlRBUkdFVF9VUkxfSEVBREVSXTogcmVxdWVzdENvbmZpZy51cmwgfSkgfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlkZGxld2FyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/middleware.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/queue.js":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/queue.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createQueueClient = void 0;\nconst request_1 = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/@fal-ai/client/src/request.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/@fal-ai/client/src/response.js\");\nconst retry_1 = __webpack_require__(/*! ./retry */ \"(rsc)/./node_modules/@fal-ai/client/src/retry.js\");\nconst streaming_1 = __webpack_require__(/*! ./streaming */ \"(rsc)/./node_modules/@fal-ai/client/src/streaming.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@fal-ai/client/src/utils.js\");\nconst DEFAULT_POLL_INTERVAL = 500;\n// Queue operations benefit from more aggressive retry policies\nconst QUEUE_RETRY_CONFIG = {\n    maxRetries: 3,\n    baseDelay: 1000,\n    maxDelay: 60000,\n    retryableStatusCodes: retry_1.DEFAULT_RETRYABLE_STATUS_CODES,\n};\n// Status checking can be retried more aggressively since it's read-only\nconst QUEUE_STATUS_RETRY_CONFIG = {\n    maxRetries: 5,\n    baseDelay: 1000,\n    maxDelay: 30000,\n    retryableStatusCodes: [...retry_1.DEFAULT_RETRYABLE_STATUS_CODES, 500],\n};\nconst createQueueClient = ({ config, storage, }) => {\n    const ref = {\n        submit(endpointId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const { webhookUrl, priority, hint } = options, runOptions = __rest(options, [\"webhookUrl\", \"priority\", \"hint\"]);\n                const input = options.input\n                    ? yield storage.transformInput(options.input)\n                    : undefined;\n                return (0, request_1.dispatchRequest)({\n                    method: options.method,\n                    targetUrl: (0, request_1.buildUrl)(endpointId, Object.assign(Object.assign({}, runOptions), { subdomain: \"queue\", query: webhookUrl ? { fal_webhook: webhookUrl } : undefined })),\n                    headers: Object.assign({ \"x-fal-queue-priority\": priority !== null && priority !== void 0 ? priority : \"normal\" }, (hint && { \"x-fal-runner-hint\": hint })),\n                    input: input,\n                    config,\n                    options: {\n                        signal: options.abortSignal,\n                        retry: QUEUE_RETRY_CONFIG,\n                    },\n                });\n            });\n        },\n        status(endpointId_1, _a) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, logs = false, abortSignal }) {\n                const appId = (0, utils_1.parseEndpointId)(endpointId);\n                const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n                return (0, request_1.dispatchRequest)({\n                    method: \"get\",\n                    targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n                        subdomain: \"queue\",\n                        query: { logs: logs ? \"1\" : \"0\" },\n                        path: `/requests/${requestId}/status`,\n                    }),\n                    config,\n                    options: {\n                        signal: abortSignal,\n                        retry: QUEUE_STATUS_RETRY_CONFIG,\n                    },\n                });\n            });\n        },\n        streamStatus(endpointId_1, _a) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, logs = false, connectionMode }) {\n                const appId = (0, utils_1.parseEndpointId)(endpointId);\n                const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n                const queryParams = {\n                    logs: logs ? \"1\" : \"0\",\n                };\n                const url = (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n                    subdomain: \"queue\",\n                    path: `/requests/${requestId}/status/stream`,\n                    query: queryParams,\n                });\n                return new streaming_1.FalStream(endpointId, config, {\n                    url,\n                    method: \"get\",\n                    connectionMode,\n                    queryParams,\n                });\n            });\n        },\n        subscribeToStatus(endpointId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const requestId = options.requestId;\n                const timeout = options.timeout;\n                let timeoutId = undefined;\n                const handleCancelError = () => {\n                    // Ignore errors as the client will follow through with the timeout\n                    // regardless of the server response. In case cancelation fails, we\n                    // still want to reject the promise and consider the client call canceled.\n                };\n                if (options.mode === \"streaming\") {\n                    const status = yield ref.streamStatus(endpointId, {\n                        requestId,\n                        logs: options.logs,\n                        connectionMode: \"connectionMode\" in options\n                            ? options.connectionMode\n                            : undefined,\n                    });\n                    const logs = [];\n                    if (timeout) {\n                        timeoutId = setTimeout(() => {\n                            status.abort();\n                            ref.cancel(endpointId, { requestId }).catch(handleCancelError);\n                            // TODO this error cannot bubble up to the user since it's thrown in\n                            // a closure in the global scope due to setTimeout behavior.\n                            // User will get a platform error instead. We should find a way to\n                            // make this behavior aligned with polling.\n                            throw new Error(`Client timed out waiting for the request to complete after ${timeout}ms`);\n                        }, timeout);\n                    }\n                    status.on(\"data\", (data) => {\n                        if (options.onQueueUpdate) {\n                            // accumulate logs to match previous polling behavior\n                            if (\"logs\" in data &&\n                                Array.isArray(data.logs) &&\n                                data.logs.length > 0) {\n                                logs.push(...data.logs);\n                            }\n                            options.onQueueUpdate(\"logs\" in data ? Object.assign(Object.assign({}, data), { logs }) : data);\n                        }\n                    });\n                    const doneStatus = yield status.done();\n                    if (timeoutId) {\n                        clearTimeout(timeoutId);\n                    }\n                    return doneStatus;\n                }\n                // default to polling until status streaming is stable and faster\n                return new Promise((resolve, reject) => {\n                    var _a;\n                    let pollingTimeoutId;\n                    // type resolution isn't great in this case, so check for its presence\n                    // and and type so the typechecker behaves as expected\n                    const pollInterval = \"pollInterval\" in options && typeof options.pollInterval === \"number\"\n                        ? ((_a = options.pollInterval) !== null && _a !== void 0 ? _a : DEFAULT_POLL_INTERVAL)\n                        : DEFAULT_POLL_INTERVAL;\n                    const clearScheduledTasks = () => {\n                        if (timeoutId) {\n                            clearTimeout(timeoutId);\n                        }\n                        if (pollingTimeoutId) {\n                            clearTimeout(pollingTimeoutId);\n                        }\n                    };\n                    if (timeout) {\n                        timeoutId = setTimeout(() => {\n                            clearScheduledTasks();\n                            ref.cancel(endpointId, { requestId }).catch(handleCancelError);\n                            reject(new Error(`Client timed out waiting for the request to complete after ${timeout}ms`));\n                        }, timeout);\n                    }\n                    const poll = () => __awaiter(this, void 0, void 0, function* () {\n                        var _a;\n                        try {\n                            const requestStatus = yield ref.status(endpointId, {\n                                requestId,\n                                logs: (_a = options.logs) !== null && _a !== void 0 ? _a : false,\n                                abortSignal: options.abortSignal,\n                            });\n                            if (options.onQueueUpdate) {\n                                options.onQueueUpdate(requestStatus);\n                            }\n                            if (requestStatus.status === \"COMPLETED\") {\n                                clearScheduledTasks();\n                                resolve(requestStatus);\n                                return;\n                            }\n                            pollingTimeoutId = setTimeout(poll, pollInterval);\n                        }\n                        catch (error) {\n                            clearScheduledTasks();\n                            reject(error);\n                        }\n                    });\n                    poll().catch(reject);\n                });\n            });\n        },\n        result(endpointId_1, _a) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, abortSignal }) {\n                const appId = (0, utils_1.parseEndpointId)(endpointId);\n                const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n                return (0, request_1.dispatchRequest)({\n                    method: \"get\",\n                    targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n                        subdomain: \"queue\",\n                        path: `/requests/${requestId}`,\n                    }),\n                    config: Object.assign(Object.assign({}, config), { responseHandler: response_1.resultResponseHandler }),\n                    options: {\n                        signal: abortSignal,\n                        retry: QUEUE_RETRY_CONFIG,\n                    },\n                });\n            });\n        },\n        cancel(endpointId_1, _a) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, abortSignal }) {\n                const appId = (0, utils_1.parseEndpointId)(endpointId);\n                const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n                yield (0, request_1.dispatchRequest)({\n                    method: \"put\",\n                    targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n                        subdomain: \"queue\",\n                        path: `/requests/${requestId}/cancel`,\n                    }),\n                    config,\n                    options: {\n                        signal: abortSignal,\n                    },\n                });\n            });\n        },\n    };\n    return ref;\n};\nexports.createQueueClient = createQueueClient;\n//# sourceMappingURL=queue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3F1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixrQkFBa0IsbUJBQU8sQ0FBQyxxRUFBVztBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyx1RUFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUztBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RUFBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxpQkFBaUIsMENBQTBDLDBCQUEwQixhQUFhO0FBQ25NLDZDQUE2Qyx3RkFBd0YsYUFBYSwyQkFBMkI7QUFDN0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLCtFQUErRSxzQ0FBc0M7QUFDckg7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQSwwREFBMEQsT0FBTyxFQUFFLFlBQVksR0FBRyxZQUFZO0FBQzlGO0FBQ0EsaUNBQWlDLHdCQUF3QjtBQUN6RCwyQ0FBMkMsVUFBVTtBQUNyRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSwrRUFBK0UseUNBQXlDO0FBQ3hIO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTyxFQUFFLFlBQVksR0FBRyxZQUFZO0FBQzNGO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxRQUFRO0FBQ2xILHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsV0FBVyxNQUFNO0FBQ2xIO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRSwyR0FBMkcsUUFBUTtBQUNuSCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSwrRUFBK0Usd0JBQXdCO0FBQ3ZHO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0EsMERBQTBELE9BQU8sRUFBRSxZQUFZLEdBQUcsWUFBWTtBQUM5RjtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JELHFCQUFxQjtBQUNyQiwwREFBMEQsYUFBYSxtREFBbUQ7QUFDMUg7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsK0VBQStFLHdCQUF3QjtBQUN2RztBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBLDBEQUEwRCxPQUFPLEVBQUUsWUFBWSxHQUFHLFlBQVk7QUFDOUY7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NlYW4vZnV0dXJlL25vZGVfbW9kdWxlcy9AZmFsLWFpL2NsaWVudC9zcmMvcXVldWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlUXVldWVDbGllbnQgPSB2b2lkIDA7XG5jb25zdCByZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi9yZXF1ZXN0XCIpO1xuY29uc3QgcmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL3Jlc3BvbnNlXCIpO1xuY29uc3QgcmV0cnlfMSA9IHJlcXVpcmUoXCIuL3JldHJ5XCIpO1xuY29uc3Qgc3RyZWFtaW5nXzEgPSByZXF1aXJlKFwiLi9zdHJlYW1pbmdcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBERUZBVUxUX1BPTExfSU5URVJWQUwgPSA1MDA7XG4vLyBRdWV1ZSBvcGVyYXRpb25zIGJlbmVmaXQgZnJvbSBtb3JlIGFnZ3Jlc3NpdmUgcmV0cnkgcG9saWNpZXNcbmNvbnN0IFFVRVVFX1JFVFJZX0NPTkZJRyA9IHtcbiAgICBtYXhSZXRyaWVzOiAzLFxuICAgIGJhc2VEZWxheTogMTAwMCxcbiAgICBtYXhEZWxheTogNjAwMDAsXG4gICAgcmV0cnlhYmxlU3RhdHVzQ29kZXM6IHJldHJ5XzEuREVGQVVMVF9SRVRSWUFCTEVfU1RBVFVTX0NPREVTLFxufTtcbi8vIFN0YXR1cyBjaGVja2luZyBjYW4gYmUgcmV0cmllZCBtb3JlIGFnZ3Jlc3NpdmVseSBzaW5jZSBpdCdzIHJlYWQtb25seVxuY29uc3QgUVVFVUVfU1RBVFVTX1JFVFJZX0NPTkZJRyA9IHtcbiAgICBtYXhSZXRyaWVzOiA1LFxuICAgIGJhc2VEZWxheTogMTAwMCxcbiAgICBtYXhEZWxheTogMzAwMDAsXG4gICAgcmV0cnlhYmxlU3RhdHVzQ29kZXM6IFsuLi5yZXRyeV8xLkRFRkFVTFRfUkVUUllBQkxFX1NUQVRVU19DT0RFUywgNTAwXSxcbn07XG5jb25zdCBjcmVhdGVRdWV1ZUNsaWVudCA9ICh7IGNvbmZpZywgc3RvcmFnZSwgfSkgPT4ge1xuICAgIGNvbnN0IHJlZiA9IHtcbiAgICAgICAgc3VibWl0KGVuZHBvaW50SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3ZWJob29rVXJsLCBwcmlvcml0eSwgaGludCB9ID0gb3B0aW9ucywgcnVuT3B0aW9ucyA9IF9fcmVzdChvcHRpb25zLCBbXCJ3ZWJob29rVXJsXCIsIFwicHJpb3JpdHlcIiwgXCJoaW50XCJdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IG9wdGlvbnMuaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgPyB5aWVsZCBzdG9yYWdlLnRyYW5zZm9ybUlucHV0KG9wdGlvbnMuaW5wdXQpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgcmVxdWVzdF8xLmRpc3BhdGNoUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRVcmw6ICgwLCByZXF1ZXN0XzEuYnVpbGRVcmwpKGVuZHBvaW50SWQsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcnVuT3B0aW9ucyksIHsgc3ViZG9tYWluOiBcInF1ZXVlXCIsIHF1ZXJ5OiB3ZWJob29rVXJsID8geyBmYWxfd2ViaG9vazogd2ViaG9va1VybCB9IDogdW5kZWZpbmVkIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7IFwieC1mYWwtcXVldWUtcHJpb3JpdHlcIjogcHJpb3JpdHkgIT09IG51bGwgJiYgcHJpb3JpdHkgIT09IHZvaWQgMCA/IHByaW9yaXR5IDogXCJub3JtYWxcIiB9LCAoaGludCAmJiB7IFwieC1mYWwtcnVubmVyLWhpbnRcIjogaGludCB9KSksXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeTogUVVFVUVfUkVUUllfQ09ORklHLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1cyhlbmRwb2ludElkXzEsIF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKGVuZHBvaW50SWQsIHsgcmVxdWVzdElkLCBsb2dzID0gZmFsc2UsIGFib3J0U2lnbmFsIH0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcHBJZCA9ICgwLCB1dGlsc18xLnBhcnNlRW5kcG9pbnRJZCkoZW5kcG9pbnRJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYXBwSWQubmFtZXNwYWNlID8gYCR7YXBwSWQubmFtZXNwYWNlfS9gIDogXCJcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHJlcXVlc3RfMS5kaXNwYXRjaFJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldFwiLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRVcmw6ICgwLCByZXF1ZXN0XzEuYnVpbGRVcmwpKGAke3ByZWZpeH0ke2FwcElkLm93bmVyfS8ke2FwcElkLmFsaWFzfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmRvbWFpbjogXCJxdWV1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHsgbG9nczogbG9ncyA/IFwiMVwiIDogXCIwXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvcmVxdWVzdHMvJHtyZXF1ZXN0SWR9L3N0YXR1c2AsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeTogUVVFVUVfU1RBVFVTX1JFVFJZX0NPTkZJRyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzdHJlYW1TdGF0dXMoZW5kcG9pbnRJZF8xLCBfYSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24qIChlbmRwb2ludElkLCB7IHJlcXVlc3RJZCwgbG9ncyA9IGZhbHNlLCBjb25uZWN0aW9uTW9kZSB9KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwSWQgPSAoMCwgdXRpbHNfMS5wYXJzZUVuZHBvaW50SWQpKGVuZHBvaW50SWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGFwcElkLm5hbWVzcGFjZSA/IGAke2FwcElkLm5hbWVzcGFjZX0vYCA6IFwiXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3M6IGxvZ3MgPyBcIjFcIiA6IFwiMFwiLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gKDAsIHJlcXVlc3RfMS5idWlsZFVybCkoYCR7cHJlZml4fSR7YXBwSWQub3duZXJ9LyR7YXBwSWQuYWxpYXN9YCwge1xuICAgICAgICAgICAgICAgICAgICBzdWJkb21haW46IFwicXVldWVcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9yZXF1ZXN0cy8ke3JlcXVlc3RJZH0vc3RhdHVzL3N0cmVhbWAsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN0cmVhbWluZ18xLkZhbFN0cmVhbShlbmRwb2ludElkLCBjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzdWJzY3JpYmVUb1N0YXR1cyhlbmRwb2ludElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IG9wdGlvbnMucmVxdWVzdElkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgbGV0IHRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxFcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycyBhcyB0aGUgY2xpZW50IHdpbGwgZm9sbG93IHRocm91Z2ggd2l0aCB0aGUgdGltZW91dFxuICAgICAgICAgICAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHRoZSBzZXJ2ZXIgcmVzcG9uc2UuIEluIGNhc2UgY2FuY2VsYXRpb24gZmFpbHMsIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIHdhbnQgdG8gcmVqZWN0IHRoZSBwcm9taXNlIGFuZCBjb25zaWRlciB0aGUgY2xpZW50IGNhbGwgY2FuY2VsZWQuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tb2RlID09PSBcInN0cmVhbWluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHlpZWxkIHJlZi5zdHJlYW1TdGF0dXMoZW5kcG9pbnRJZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nczogb3B0aW9ucy5sb2dzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk1vZGU6IFwiY29ubmVjdGlvbk1vZGVcIiBpbiBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmNvbm5lY3Rpb25Nb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYuY2FuY2VsKGVuZHBvaW50SWQsIHsgcmVxdWVzdElkIH0pLmNhdGNoKGhhbmRsZUNhbmNlbEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgZXJyb3IgY2Fubm90IGJ1YmJsZSB1cCB0byB0aGUgdXNlciBzaW5jZSBpdCdzIHRocm93biBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgY2xvc3VyZSBpbiB0aGUgZ2xvYmFsIHNjb3BlIGR1ZSB0byBzZXRUaW1lb3V0IGJlaGF2aW9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgd2lsbCBnZXQgYSBwbGF0Zm9ybSBlcnJvciBpbnN0ZWFkLiBXZSBzaG91bGQgZmluZCBhIHdheSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhpcyBiZWhhdmlvciBhbGlnbmVkIHdpdGggcG9sbGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCB0aW1lZCBvdXQgd2FpdGluZyBmb3IgdGhlIHJlcXVlc3QgdG8gY29tcGxldGUgYWZ0ZXIgJHt0aW1lb3V0fW1zYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMub24oXCJkYXRhXCIsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vblF1ZXVlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjdW11bGF0ZSBsb2dzIHRvIG1hdGNoIHByZXZpb3VzIHBvbGxpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJsb2dzXCIgaW4gZGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEubG9ncykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5sb2dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ncy5wdXNoKC4uLmRhdGEubG9ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25RdWV1ZVVwZGF0ZShcImxvZ3NcIiBpbiBkYXRhID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgeyBsb2dzIH0pIDogZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb25lU3RhdHVzID0geWllbGQgc3RhdHVzLmRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbmVTdGF0dXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gcG9sbGluZyB1bnRpbCBzdGF0dXMgc3RyZWFtaW5nIGlzIHN0YWJsZSBhbmQgZmFzdGVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9sbGluZ1RpbWVvdXRJZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHlwZSByZXNvbHV0aW9uIGlzbid0IGdyZWF0IGluIHRoaXMgY2FzZSwgc28gY2hlY2sgZm9yIGl0cyBwcmVzZW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgYW5kIHR5cGUgc28gdGhlIHR5cGVjaGVja2VyIGJlaGF2ZXMgYXMgZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9sbEludGVydmFsID0gXCJwb2xsSW50ZXJ2YWxcIiBpbiBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnBvbGxJbnRlcnZhbCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoKF9hID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERFRkFVTFRfUE9MTF9JTlRFUlZBTClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogREVGQVVMVF9QT0xMX0lOVEVSVkFMO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGVhclNjaGVkdWxlZFRhc2tzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvbGxpbmdUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocG9sbGluZ1RpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclNjaGVkdWxlZFRhc2tzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLmNhbmNlbChlbmRwb2ludElkLCB7IHJlcXVlc3RJZCB9KS5jYXRjaChoYW5kbGVDYW5jZWxFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQ2xpZW50IHRpbWVkIG91dCB3YWl0aW5nIGZvciB0aGUgcmVxdWVzdCB0byBjb21wbGV0ZSBhZnRlciAke3RpbWVvdXR9bXNgKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2xsID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0U3RhdHVzID0geWllbGQgcmVmLnN0YXR1cyhlbmRwb2ludElkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nczogKF9hID0gb3B0aW9ucy5sb2dzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25RdWV1ZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uUXVldWVVcGRhdGUocmVxdWVzdFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0U3RhdHVzLnN0YXR1cyA9PT0gXCJDT01QTEVURURcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclNjaGVkdWxlZFRhc2tzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9sbGluZ1RpbWVvdXRJZCA9IHNldFRpbWVvdXQocG9sbCwgcG9sbEludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyU2NoZWR1bGVkVGFza3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcG9sbCgpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0KGVuZHBvaW50SWRfMSwgX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAoZW5kcG9pbnRJZCwgeyByZXF1ZXN0SWQsIGFib3J0U2lnbmFsIH0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcHBJZCA9ICgwLCB1dGlsc18xLnBhcnNlRW5kcG9pbnRJZCkoZW5kcG9pbnRJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYXBwSWQubmFtZXNwYWNlID8gYCR7YXBwSWQubmFtZXNwYWNlfS9gIDogXCJcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHJlcXVlc3RfMS5kaXNwYXRjaFJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldFwiLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRVcmw6ICgwLCByZXF1ZXN0XzEuYnVpbGRVcmwpKGAke3ByZWZpeH0ke2FwcElkLm93bmVyfS8ke2FwcElkLmFsaWFzfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmRvbWFpbjogXCJxdWV1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9yZXF1ZXN0cy8ke3JlcXVlc3RJZH1gLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyksIHsgcmVzcG9uc2VIYW5kbGVyOiByZXNwb25zZV8xLnJlc3VsdFJlc3BvbnNlSGFuZGxlciB9KSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5OiBRVUVVRV9SRVRSWV9DT05GSUcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsKGVuZHBvaW50SWRfMSwgX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAoZW5kcG9pbnRJZCwgeyByZXF1ZXN0SWQsIGFib3J0U2lnbmFsIH0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcHBJZCA9ICgwLCB1dGlsc18xLnBhcnNlRW5kcG9pbnRJZCkoZW5kcG9pbnRJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYXBwSWQubmFtZXNwYWNlID8gYCR7YXBwSWQubmFtZXNwYWNlfS9gIDogXCJcIjtcbiAgICAgICAgICAgICAgICB5aWVsZCAoMCwgcmVxdWVzdF8xLmRpc3BhdGNoUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwicHV0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFVybDogKDAsIHJlcXVlc3RfMS5idWlsZFVybCkoYCR7cHJlZml4fSR7YXBwSWQub3duZXJ9LyR7YXBwSWQuYWxpYXN9YCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViZG9tYWluOiBcInF1ZXVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL3JlcXVlc3RzLyR7cmVxdWVzdElkfS9jYW5jZWxgLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gcmVmO1xufTtcbmV4cG9ydHMuY3JlYXRlUXVldWVDbGllbnQgPSBjcmVhdGVRdWV1ZUNsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/realtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/realtime.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createRealtimeClient = createRealtimeClient;\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ \"(rsc)/./node_modules/@msgpack/msgpack/dist.esm/index.mjs\");\nconst robot3_1 = __webpack_require__(/*! robot3 */ \"(rsc)/./node_modules/robot3/dist/machine.js\");\nconst auth_1 = __webpack_require__(/*! ./auth */ \"(rsc)/./node_modules/@fal-ai/client/src/auth.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/@fal-ai/client/src/response.js\");\nconst runtime_1 = __webpack_require__(/*! ./runtime */ \"(rsc)/./node_modules/@fal-ai/client/src/runtime.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@fal-ai/client/src/utils.js\");\nconst initialState = () => ({\n    enqueuedMessage: undefined,\n});\nfunction hasToken(context) {\n    return context.token !== undefined;\n}\nfunction noToken(context) {\n    return !hasToken(context);\n}\nfunction enqueueMessage(context, event) {\n    return Object.assign(Object.assign({}, context), { enqueuedMessage: event.message });\n}\nfunction closeConnection(context) {\n    if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n        context.websocket.close();\n    }\n    return Object.assign(Object.assign({}, context), { websocket: undefined });\n}\nfunction sendMessage(context, event) {\n    if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n        if (event.message instanceof Uint8Array) {\n            context.websocket.send(event.message);\n        }\n        else {\n            context.websocket.send((0, msgpack_1.encode)(event.message));\n        }\n        return Object.assign(Object.assign({}, context), { enqueuedMessage: undefined });\n    }\n    return Object.assign(Object.assign({}, context), { enqueuedMessage: event.message });\n}\nfunction expireToken(context) {\n    return Object.assign(Object.assign({}, context), { token: undefined });\n}\nfunction setToken(context, event) {\n    return Object.assign(Object.assign({}, context), { token: event.token });\n}\nfunction connectionEstablished(context, event) {\n    return Object.assign(Object.assign({}, context), { websocket: event.websocket });\n}\n// State machine\nconst connectionStateMachine = (0, robot3_1.createMachine)(\"idle\", {\n    idle: (0, robot3_1.state)((0, robot3_1.transition)(\"send\", \"connecting\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"expireToken\", \"idle\", (0, robot3_1.reduce)(expireToken)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n    connecting: (0, robot3_1.state)((0, robot3_1.transition)(\"connecting\", \"connecting\"), (0, robot3_1.transition)(\"connected\", \"active\", (0, robot3_1.reduce)(connectionEstablished)), (0, robot3_1.transition)(\"connectionClosed\", \"idle\", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)(\"send\", \"connecting\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.immediate)(\"authRequired\", (0, robot3_1.guard)(noToken))),\n    authRequired: (0, robot3_1.state)((0, robot3_1.transition)(\"initiateAuth\", \"authInProgress\"), (0, robot3_1.transition)(\"send\", \"authRequired\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n    authInProgress: (0, robot3_1.state)((0, robot3_1.transition)(\"authenticated\", \"connecting\", (0, robot3_1.reduce)(setToken)), (0, robot3_1.transition)(\"unauthorized\", \"idle\", (0, robot3_1.reduce)(expireToken), (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)(\"send\", \"authInProgress\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n    active: (0, robot3_1.state)((0, robot3_1.transition)(\"send\", \"active\", (0, robot3_1.reduce)(sendMessage)), (0, robot3_1.transition)(\"unauthorized\", \"idle\", (0, robot3_1.reduce)(expireToken)), (0, robot3_1.transition)(\"connectionClosed\", \"idle\", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n    failed: (0, robot3_1.state)((0, robot3_1.transition)(\"send\", \"failed\"), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n}, initialState);\nfunction buildRealtimeUrl(app, { token, maxBuffering }) {\n    if (maxBuffering !== undefined && (maxBuffering < 1 || maxBuffering > 60)) {\n        throw new Error(\"The `maxBuffering` must be between 1 and 60 (inclusive)\");\n    }\n    const queryParams = new URLSearchParams({\n        fal_jwt_token: token,\n    });\n    if (maxBuffering !== undefined) {\n        queryParams.set(\"max_buffering\", maxBuffering.toFixed(0));\n    }\n    const appId = (0, utils_1.ensureEndpointIdFormat)(app);\n    return `wss://fal.run/${appId}/realtime?${queryParams.toString()}`;\n}\nconst DEFAULT_THROTTLE_INTERVAL = 128;\nfunction isUnauthorizedError(message) {\n    // TODO we need better protocol definition with error codes\n    return message[\"status\"] === \"error\" && message[\"error\"] === \"Unauthorized\";\n}\n/**\n * See https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n */\nconst WebSocketErrorCodes = {\n    NORMAL_CLOSURE: 1000,\n    GOING_AWAY: 1001,\n};\nconst connectionCache = new Map();\nconst connectionCallbacks = new Map();\nfunction reuseInterpreter(key, throttleInterval, onChange) {\n    if (!connectionCache.has(key)) {\n        const machine = (0, robot3_1.interpret)(connectionStateMachine, onChange);\n        connectionCache.set(key, Object.assign(Object.assign({}, machine), { throttledSend: throttleInterval > 0\n                ? (0, utils_1.throttle)(machine.send, throttleInterval, true)\n                : machine.send }));\n    }\n    return connectionCache.get(key);\n}\nconst noop = () => {\n    /* No-op */\n};\n/**\n * A no-op connection that does not send any message.\n * Useful on the frameworks that reuse code for both ssr and csr (e.g. Next)\n * so the call when doing ssr has no side-effects.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst NoOpConnection = {\n    send: noop,\n    close: noop,\n};\nfunction isSuccessfulResult(data) {\n    return (data.status !== \"error\" &&\n        data.type !== \"x-fal-message\" &&\n        !isFalErrorResult(data));\n}\nfunction isFalErrorResult(data) {\n    return data.type === \"x-fal-error\";\n}\nfunction createRealtimeClient({ config, }) {\n    return {\n        connect(app, handler) {\n            const { \n            // if running on React in the server, set clientOnly to true by default\n            clientOnly = (0, utils_1.isReact)() && !(0, runtime_1.isBrowser)(), connectionKey = crypto.randomUUID(), maxBuffering, throttleInterval = DEFAULT_THROTTLE_INTERVAL, } = handler;\n            if (clientOnly && !(0, runtime_1.isBrowser)()) {\n                return NoOpConnection;\n            }\n            let previousState;\n            // Although the state machine is cached so we don't open multiple connections,\n            // we still need to update the callbacks so we can call the correct references\n            // when the state machine is reused. This is needed because the callbacks\n            // are passed as part of the handler object, which can be different across\n            // different calls to `connect`.\n            connectionCallbacks.set(connectionKey, {\n                onError: handler.onError,\n                onResult: handler.onResult,\n            });\n            const getCallbacks = () => connectionCallbacks.get(connectionKey);\n            const stateMachine = reuseInterpreter(connectionKey, throttleInterval, ({ context, machine, send }) => {\n                const { enqueuedMessage, token } = context;\n                if (machine.current === \"active\" && enqueuedMessage) {\n                    send({ type: \"send\", message: enqueuedMessage });\n                }\n                if (machine.current === \"authRequired\" &&\n                    token === undefined &&\n                    previousState !== machine.current) {\n                    send({ type: \"initiateAuth\" });\n                    (0, auth_1.getTemporaryAuthToken)(app, config)\n                        .then((token) => {\n                        send({ type: \"authenticated\", token });\n                        const tokenExpirationTimeout = Math.round(auth_1.TOKEN_EXPIRATION_SECONDS * 0.9 * 1000);\n                        setTimeout(() => {\n                            send({ type: \"expireToken\" });\n                        }, tokenExpirationTimeout);\n                    })\n                        .catch((error) => {\n                        send({ type: \"unauthorized\", error });\n                    });\n                }\n                if (machine.current === \"connecting\" &&\n                    previousState !== machine.current &&\n                    token !== undefined) {\n                    const ws = new WebSocket(buildRealtimeUrl(app, { token, maxBuffering }));\n                    ws.onopen = () => {\n                        send({ type: \"connected\", websocket: ws });\n                    };\n                    ws.onclose = (event) => {\n                        if (event.code !== WebSocketErrorCodes.NORMAL_CLOSURE) {\n                            const { onError = noop } = getCallbacks();\n                            onError(new response_1.ApiError({\n                                message: `Error closing the connection: ${event.reason}`,\n                                status: event.code,\n                            }));\n                        }\n                        send({ type: \"connectionClosed\", code: event.code });\n                    };\n                    ws.onerror = (event) => {\n                        // TODO specify error protocol for identified errors\n                        const { onError = noop } = getCallbacks();\n                        onError(new response_1.ApiError({ message: \"Unknown error\", status: 500 }));\n                    };\n                    ws.onmessage = (event) => {\n                        const { onResult } = getCallbacks();\n                        // Handle binary messages as msgpack messages\n                        if (event.data instanceof ArrayBuffer) {\n                            const result = (0, msgpack_1.decode)(new Uint8Array(event.data));\n                            onResult(result);\n                            return;\n                        }\n                        if (event.data instanceof Uint8Array) {\n                            const result = (0, msgpack_1.decode)(event.data);\n                            onResult(result);\n                            return;\n                        }\n                        if (event.data instanceof Blob) {\n                            event.data.arrayBuffer().then((buffer) => {\n                                const result = (0, msgpack_1.decode)(new Uint8Array(buffer));\n                                onResult(result);\n                            });\n                            return;\n                        }\n                        // Otherwise handle strings as plain JSON messages\n                        const data = JSON.parse(event.data);\n                        // Drop messages that are not related to the actual result.\n                        // In the future, we might want to handle other types of messages.\n                        // TODO: specify the fal ws protocol format\n                        if (isUnauthorizedError(data)) {\n                            send({\n                                type: \"unauthorized\",\n                                error: new Error(\"Unauthorized\"),\n                            });\n                            return;\n                        }\n                        if (isSuccessfulResult(data)) {\n                            onResult(data);\n                            return;\n                        }\n                        if (isFalErrorResult(data)) {\n                            if (data.error === \"TIMEOUT\") {\n                                // Timeout error messages just indicate that the connection hasn't\n                                // received an incoming message for a while. We don't need to\n                                // handle them as errors.\n                                return;\n                            }\n                            const { onError = noop } = getCallbacks();\n                            onError(new response_1.ApiError({\n                                message: `${data.error}: ${data.reason}`,\n                                // TODO better error status code\n                                status: 400,\n                                body: data,\n                            }));\n                            return;\n                        }\n                    };\n                }\n                previousState = machine.current;\n            });\n            const send = (input) => {\n                // Use throttled send to avoid sending too many messages\n                stateMachine.throttledSend({\n                    type: \"send\",\n                    message: input,\n                });\n            };\n            const close = () => {\n                stateMachine.send({ type: \"close\" });\n            };\n            return {\n                send,\n                close,\n            };\n        },\n    };\n}\n//# sourceMappingURL=realtime.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3JlYWx0aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QjtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGtGQUFrQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQywyREFBUTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsK0RBQVE7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsdUVBQVk7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMscUVBQVc7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQVM7QUFDakM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjLGdDQUFnQztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWMsc0JBQXNCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLDRCQUE0QjtBQUN2RjtBQUNBLHlDQUF5QyxjQUFjLGdDQUFnQztBQUN2RjtBQUNBO0FBQ0EseUNBQXlDLGNBQWMsa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYyxvQkFBb0I7QUFDM0U7QUFDQTtBQUNBLHlDQUF5QyxjQUFjLDRCQUE0QjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU0sWUFBWSx1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGNBQWM7QUFDN0U7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtTEFBbUw7QUFDbkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0ZBQXNGLHdCQUF3QjtBQUM5Ryx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0EsMkJBQTJCLHdDQUF3QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBLCtCQUErQiw4QkFBOEI7QUFDN0Q7QUFDQTtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBLCtCQUErQiw2QkFBNkI7QUFDNUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHFCQUFxQjtBQUMxRjtBQUNBLCtCQUErQixrQ0FBa0M7QUFDakU7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsK0JBQStCLDRDQUE0QztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pELDBEQUEwRCx1Q0FBdUM7QUFDakc7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBLDRDQUE0QyxXQUFXLElBQUksWUFBWTtBQUN2RTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NlYW4vZnV0dXJlL25vZGVfbW9kdWxlcy9AZmFsLWFpL2NsaWVudC9zcmMvcmVhbHRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVJlYWx0aW1lQ2xpZW50ID0gY3JlYXRlUmVhbHRpbWVDbGllbnQ7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCBtc2dwYWNrXzEgPSByZXF1aXJlKFwiQG1zZ3BhY2svbXNncGFja1wiKTtcbmNvbnN0IHJvYm90M18xID0gcmVxdWlyZShcInJvYm90M1wiKTtcbmNvbnN0IGF1dGhfMSA9IHJlcXVpcmUoXCIuL2F1dGhcIik7XG5jb25zdCByZXNwb25zZV8xID0gcmVxdWlyZShcIi4vcmVzcG9uc2VcIik7XG5jb25zdCBydW50aW1lXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgaW5pdGlhbFN0YXRlID0gKCkgPT4gKHtcbiAgICBlbnF1ZXVlZE1lc3NhZ2U6IHVuZGVmaW5lZCxcbn0pO1xuZnVuY3Rpb24gaGFzVG9rZW4oY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0LnRva2VuICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBub1Rva2VuKGNvbnRleHQpIHtcbiAgICByZXR1cm4gIWhhc1Rva2VuKGNvbnRleHQpO1xufVxuZnVuY3Rpb24gZW5xdWV1ZU1lc3NhZ2UoY29udGV4dCwgZXZlbnQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KSwgeyBlbnF1ZXVlZE1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UgfSk7XG59XG5mdW5jdGlvbiBjbG9zZUNvbm5lY3Rpb24oY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LndlYnNvY2tldCAmJiBjb250ZXh0LndlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICBjb250ZXh0LndlYnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KSwgeyB3ZWJzb2NrZXQ6IHVuZGVmaW5lZCB9KTtcbn1cbmZ1bmN0aW9uIHNlbmRNZXNzYWdlKGNvbnRleHQsIGV2ZW50KSB7XG4gICAgaWYgKGNvbnRleHQud2Vic29ja2V0ICYmIGNvbnRleHQud2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgIGlmIChldmVudC5tZXNzYWdlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgY29udGV4dC53ZWJzb2NrZXQuc2VuZChldmVudC5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQud2Vic29ja2V0LnNlbmQoKDAsIG1zZ3BhY2tfMS5lbmNvZGUpKGV2ZW50Lm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KSwgeyBlbnF1ZXVlZE1lc3NhZ2U6IHVuZGVmaW5lZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dCksIHsgZW5xdWV1ZWRNZXNzYWdlOiBldmVudC5tZXNzYWdlIH0pO1xufVxuZnVuY3Rpb24gZXhwaXJlVG9rZW4oY29udGV4dCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQpLCB7IHRva2VuOiB1bmRlZmluZWQgfSk7XG59XG5mdW5jdGlvbiBzZXRUb2tlbihjb250ZXh0LCBldmVudCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQpLCB7IHRva2VuOiBldmVudC50b2tlbiB9KTtcbn1cbmZ1bmN0aW9uIGNvbm5lY3Rpb25Fc3RhYmxpc2hlZChjb250ZXh0LCBldmVudCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQpLCB7IHdlYnNvY2tldDogZXZlbnQud2Vic29ja2V0IH0pO1xufVxuLy8gU3RhdGUgbWFjaGluZVxuY29uc3QgY29ubmVjdGlvblN0YXRlTWFjaGluZSA9ICgwLCByb2JvdDNfMS5jcmVhdGVNYWNoaW5lKShcImlkbGVcIiwge1xuICAgIGlkbGU6ICgwLCByb2JvdDNfMS5zdGF0ZSkoKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwic2VuZFwiLCBcImNvbm5lY3RpbmdcIiwgKDAsIHJvYm90M18xLnJlZHVjZSkoZW5xdWV1ZU1lc3NhZ2UpKSwgKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwiZXhwaXJlVG9rZW5cIiwgXCJpZGxlXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGV4cGlyZVRva2VuKSksICgwLCByb2JvdDNfMS50cmFuc2l0aW9uKShcImNsb3NlXCIsIFwiaWRsZVwiLCAoMCwgcm9ib3QzXzEucmVkdWNlKShjbG9zZUNvbm5lY3Rpb24pKSksXG4gICAgY29ubmVjdGluZzogKDAsIHJvYm90M18xLnN0YXRlKSgoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJjb25uZWN0aW5nXCIsIFwiY29ubmVjdGluZ1wiKSwgKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwiY29ubmVjdGVkXCIsIFwiYWN0aXZlXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGNvbm5lY3Rpb25Fc3RhYmxpc2hlZCkpLCAoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJjb25uZWN0aW9uQ2xvc2VkXCIsIFwiaWRsZVwiLCAoMCwgcm9ib3QzXzEucmVkdWNlKShjbG9zZUNvbm5lY3Rpb24pKSwgKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwic2VuZFwiLCBcImNvbm5lY3RpbmdcIiwgKDAsIHJvYm90M18xLnJlZHVjZSkoZW5xdWV1ZU1lc3NhZ2UpKSwgKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwiY2xvc2VcIiwgXCJpZGxlXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGNsb3NlQ29ubmVjdGlvbikpLCAoMCwgcm9ib3QzXzEuaW1tZWRpYXRlKShcImF1dGhSZXF1aXJlZFwiLCAoMCwgcm9ib3QzXzEuZ3VhcmQpKG5vVG9rZW4pKSksXG4gICAgYXV0aFJlcXVpcmVkOiAoMCwgcm9ib3QzXzEuc3RhdGUpKCgwLCByb2JvdDNfMS50cmFuc2l0aW9uKShcImluaXRpYXRlQXV0aFwiLCBcImF1dGhJblByb2dyZXNzXCIpLCAoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJzZW5kXCIsIFwiYXV0aFJlcXVpcmVkXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGVucXVldWVNZXNzYWdlKSksICgwLCByb2JvdDNfMS50cmFuc2l0aW9uKShcImNsb3NlXCIsIFwiaWRsZVwiLCAoMCwgcm9ib3QzXzEucmVkdWNlKShjbG9zZUNvbm5lY3Rpb24pKSksXG4gICAgYXV0aEluUHJvZ3Jlc3M6ICgwLCByb2JvdDNfMS5zdGF0ZSkoKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwiYXV0aGVudGljYXRlZFwiLCBcImNvbm5lY3RpbmdcIiwgKDAsIHJvYm90M18xLnJlZHVjZSkoc2V0VG9rZW4pKSwgKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwidW5hdXRob3JpemVkXCIsIFwiaWRsZVwiLCAoMCwgcm9ib3QzXzEucmVkdWNlKShleHBpcmVUb2tlbiksICgwLCByb2JvdDNfMS5yZWR1Y2UpKGNsb3NlQ29ubmVjdGlvbikpLCAoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJzZW5kXCIsIFwiYXV0aEluUHJvZ3Jlc3NcIiwgKDAsIHJvYm90M18xLnJlZHVjZSkoZW5xdWV1ZU1lc3NhZ2UpKSwgKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwiY2xvc2VcIiwgXCJpZGxlXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGNsb3NlQ29ubmVjdGlvbikpKSxcbiAgICBhY3RpdmU6ICgwLCByb2JvdDNfMS5zdGF0ZSkoKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwic2VuZFwiLCBcImFjdGl2ZVwiLCAoMCwgcm9ib3QzXzEucmVkdWNlKShzZW5kTWVzc2FnZSkpLCAoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJ1bmF1dGhvcml6ZWRcIiwgXCJpZGxlXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGV4cGlyZVRva2VuKSksICgwLCByb2JvdDNfMS50cmFuc2l0aW9uKShcImNvbm5lY3Rpb25DbG9zZWRcIiwgXCJpZGxlXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGNsb3NlQ29ubmVjdGlvbikpLCAoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJjbG9zZVwiLCBcImlkbGVcIiwgKDAsIHJvYm90M18xLnJlZHVjZSkoY2xvc2VDb25uZWN0aW9uKSkpLFxuICAgIGZhaWxlZDogKDAsIHJvYm90M18xLnN0YXRlKSgoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJzZW5kXCIsIFwiZmFpbGVkXCIpLCAoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJjbG9zZVwiLCBcImlkbGVcIiwgKDAsIHJvYm90M18xLnJlZHVjZSkoY2xvc2VDb25uZWN0aW9uKSkpLFxufSwgaW5pdGlhbFN0YXRlKTtcbmZ1bmN0aW9uIGJ1aWxkUmVhbHRpbWVVcmwoYXBwLCB7IHRva2VuLCBtYXhCdWZmZXJpbmcgfSkge1xuICAgIGlmIChtYXhCdWZmZXJpbmcgIT09IHVuZGVmaW5lZCAmJiAobWF4QnVmZmVyaW5nIDwgMSB8fCBtYXhCdWZmZXJpbmcgPiA2MCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBtYXhCdWZmZXJpbmdgIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA2MCAoaW5jbHVzaXZlKVwiKTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgZmFsX2p3dF90b2tlbjogdG9rZW4sXG4gICAgfSk7XG4gICAgaWYgKG1heEJ1ZmZlcmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zLnNldChcIm1heF9idWZmZXJpbmdcIiwgbWF4QnVmZmVyaW5nLnRvRml4ZWQoMCkpO1xuICAgIH1cbiAgICBjb25zdCBhcHBJZCA9ICgwLCB1dGlsc18xLmVuc3VyZUVuZHBvaW50SWRGb3JtYXQpKGFwcCk7XG4gICAgcmV0dXJuIGB3c3M6Ly9mYWwucnVuLyR7YXBwSWR9L3JlYWx0aW1lPyR7cXVlcnlQYXJhbXMudG9TdHJpbmcoKX1gO1xufVxuY29uc3QgREVGQVVMVF9USFJPVFRMRV9JTlRFUlZBTCA9IDEyODtcbmZ1bmN0aW9uIGlzVW5hdXRob3JpemVkRXJyb3IobWVzc2FnZSkge1xuICAgIC8vIFRPRE8gd2UgbmVlZCBiZXR0ZXIgcHJvdG9jb2wgZGVmaW5pdGlvbiB3aXRoIGVycm9yIGNvZGVzXG4gICAgcmV0dXJuIG1lc3NhZ2VbXCJzdGF0dXNcIl0gPT09IFwiZXJyb3JcIiAmJiBtZXNzYWdlW1wiZXJyb3JcIl0gPT09IFwiVW5hdXRob3JpemVkXCI7XG59XG4vKipcbiAqIFNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjQ1NS5odG1sI3NlY3Rpb24tNy40LjFcbiAqL1xuY29uc3QgV2ViU29ja2V0RXJyb3JDb2RlcyA9IHtcbiAgICBOT1JNQUxfQ0xPU1VSRTogMTAwMCxcbiAgICBHT0lOR19BV0FZOiAxMDAxLFxufTtcbmNvbnN0IGNvbm5lY3Rpb25DYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IGNvbm5lY3Rpb25DYWxsYmFja3MgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZXVzZUludGVycHJldGVyKGtleSwgdGhyb3R0bGVJbnRlcnZhbCwgb25DaGFuZ2UpIHtcbiAgICBpZiAoIWNvbm5lY3Rpb25DYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICBjb25zdCBtYWNoaW5lID0gKDAsIHJvYm90M18xLmludGVycHJldCkoY29ubmVjdGlvblN0YXRlTWFjaGluZSwgb25DaGFuZ2UpO1xuICAgICAgICBjb25uZWN0aW9uQ2FjaGUuc2V0KGtleSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYWNoaW5lKSwgeyB0aHJvdHRsZWRTZW5kOiB0aHJvdHRsZUludGVydmFsID4gMFxuICAgICAgICAgICAgICAgID8gKDAsIHV0aWxzXzEudGhyb3R0bGUpKG1hY2hpbmUuc2VuZCwgdGhyb3R0bGVJbnRlcnZhbCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICA6IG1hY2hpbmUuc2VuZCB9KSk7XG4gICAgfVxuICAgIHJldHVybiBjb25uZWN0aW9uQ2FjaGUuZ2V0KGtleSk7XG59XG5jb25zdCBub29wID0gKCkgPT4ge1xuICAgIC8qIE5vLW9wICovXG59O1xuLyoqXG4gKiBBIG5vLW9wIGNvbm5lY3Rpb24gdGhhdCBkb2VzIG5vdCBzZW5kIGFueSBtZXNzYWdlLlxuICogVXNlZnVsIG9uIHRoZSBmcmFtZXdvcmtzIHRoYXQgcmV1c2UgY29kZSBmb3IgYm90aCBzc3IgYW5kIGNzciAoZS5nLiBOZXh0KVxuICogc28gdGhlIGNhbGwgd2hlbiBkb2luZyBzc3IgaGFzIG5vIHNpZGUtZWZmZWN0cy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IE5vT3BDb25uZWN0aW9uID0ge1xuICAgIHNlbmQ6IG5vb3AsXG4gICAgY2xvc2U6IG5vb3AsXG59O1xuZnVuY3Rpb24gaXNTdWNjZXNzZnVsUmVzdWx0KGRhdGEpIHtcbiAgICByZXR1cm4gKGRhdGEuc3RhdHVzICE9PSBcImVycm9yXCIgJiZcbiAgICAgICAgZGF0YS50eXBlICE9PSBcIngtZmFsLW1lc3NhZ2VcIiAmJlxuICAgICAgICAhaXNGYWxFcnJvclJlc3VsdChkYXRhKSk7XG59XG5mdW5jdGlvbiBpc0ZhbEVycm9yUmVzdWx0KGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS50eXBlID09PSBcIngtZmFsLWVycm9yXCI7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFsdGltZUNsaWVudCh7IGNvbmZpZywgfSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbm5lY3QoYXBwLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgLy8gaWYgcnVubmluZyBvbiBSZWFjdCBpbiB0aGUgc2VydmVyLCBzZXQgY2xpZW50T25seSB0byB0cnVlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIGNsaWVudE9ubHkgPSAoMCwgdXRpbHNfMS5pc1JlYWN0KSgpICYmICEoMCwgcnVudGltZV8xLmlzQnJvd3NlcikoKSwgY29ubmVjdGlvbktleSA9IGNyeXB0by5yYW5kb21VVUlEKCksIG1heEJ1ZmZlcmluZywgdGhyb3R0bGVJbnRlcnZhbCA9IERFRkFVTFRfVEhST1RUTEVfSU5URVJWQUwsIH0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgaWYgKGNsaWVudE9ubHkgJiYgISgwLCBydW50aW1lXzEuaXNCcm93c2VyKSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5vT3BDb25uZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgICAvLyBBbHRob3VnaCB0aGUgc3RhdGUgbWFjaGluZSBpcyBjYWNoZWQgc28gd2UgZG9uJ3Qgb3BlbiBtdWx0aXBsZSBjb25uZWN0aW9ucyxcbiAgICAgICAgICAgIC8vIHdlIHN0aWxsIG5lZWQgdG8gdXBkYXRlIHRoZSBjYWxsYmFja3Mgc28gd2UgY2FuIGNhbGwgdGhlIGNvcnJlY3QgcmVmZXJlbmNlc1xuICAgICAgICAgICAgLy8gd2hlbiB0aGUgc3RhdGUgbWFjaGluZSBpcyByZXVzZWQuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGNhbGxiYWNrc1xuICAgICAgICAgICAgLy8gYXJlIHBhc3NlZCBhcyBwYXJ0IG9mIHRoZSBoYW5kbGVyIG9iamVjdCwgd2hpY2ggY2FuIGJlIGRpZmZlcmVudCBhY3Jvc3NcbiAgICAgICAgICAgIC8vIGRpZmZlcmVudCBjYWxscyB0byBgY29ubmVjdGAuXG4gICAgICAgICAgICBjb25uZWN0aW9uQ2FsbGJhY2tzLnNldChjb25uZWN0aW9uS2V5LCB7XG4gICAgICAgICAgICAgICAgb25FcnJvcjogaGFuZGxlci5vbkVycm9yLFxuICAgICAgICAgICAgICAgIG9uUmVzdWx0OiBoYW5kbGVyLm9uUmVzdWx0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBnZXRDYWxsYmFja3MgPSAoKSA9PiBjb25uZWN0aW9uQ2FsbGJhY2tzLmdldChjb25uZWN0aW9uS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlTWFjaGluZSA9IHJldXNlSW50ZXJwcmV0ZXIoY29ubmVjdGlvbktleSwgdGhyb3R0bGVJbnRlcnZhbCwgKHsgY29udGV4dCwgbWFjaGluZSwgc2VuZCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbnF1ZXVlZE1lc3NhZ2UsIHRva2VuIH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmIChtYWNoaW5lLmN1cnJlbnQgPT09IFwiYWN0aXZlXCIgJiYgZW5xdWV1ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcInNlbmRcIiwgbWVzc2FnZTogZW5xdWV1ZWRNZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFjaGluZS5jdXJyZW50ID09PSBcImF1dGhSZXF1aXJlZFwiICYmXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNTdGF0ZSAhPT0gbWFjaGluZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcImluaXRpYXRlQXV0aFwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAoMCwgYXV0aF8xLmdldFRlbXBvcmFyeUF1dGhUb2tlbikoYXBwLCBjb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcImF1dGhlbnRpY2F0ZWRcIiwgdG9rZW4gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbkV4cGlyYXRpb25UaW1lb3V0ID0gTWF0aC5yb3VuZChhdXRoXzEuVE9LRU5fRVhQSVJBVElPTl9TRUNPTkRTICogMC45ICogMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kKHsgdHlwZTogXCJleHBpcmVUb2tlblwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdG9rZW5FeHBpcmF0aW9uVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kKHsgdHlwZTogXCJ1bmF1dGhvcml6ZWRcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFjaGluZS5jdXJyZW50ID09PSBcImNvbm5lY3RpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1N0YXRlICE9PSBtYWNoaW5lLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQoYnVpbGRSZWFsdGltZVVybChhcHAsIHsgdG9rZW4sIG1heEJ1ZmZlcmluZyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcImNvbm5lY3RlZFwiLCB3ZWJzb2NrZXQ6IHdzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB3cy5vbmNsb3NlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY29kZSAhPT0gV2ViU29ja2V0RXJyb3JDb2Rlcy5OT1JNQUxfQ0xPU1VSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25FcnJvciA9IG5vb3AgfSA9IGdldENhbGxiYWNrcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IobmV3IHJlc3BvbnNlXzEuQXBpRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXJyb3IgY2xvc2luZyB0aGUgY29ubmVjdGlvbjogJHtldmVudC5yZWFzb259YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBldmVudC5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcImNvbm5lY3Rpb25DbG9zZWRcIiwgY29kZTogZXZlbnQuY29kZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgd3Mub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBzcGVjaWZ5IGVycm9yIHByb3RvY29sIGZvciBpZGVudGlmaWVkIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvbkVycm9yID0gbm9vcCB9ID0gZ2V0Q2FsbGJhY2tzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG5ldyByZXNwb25zZV8xLkFwaUVycm9yKHsgbWVzc2FnZTogXCJVbmtub3duIGVycm9yXCIsIHN0YXR1czogNTAwIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgd3Mub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9uUmVzdWx0IH0gPSBnZXRDYWxsYmFja3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBiaW5hcnkgbWVzc2FnZXMgYXMgbXNncGFjayBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBtc2dwYWNrXzEuZGVjb2RlKShuZXcgVWludDhBcnJheShldmVudC5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgbXNncGFja18xLmRlY29kZSkoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLmFycmF5QnVmZmVyKCkudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBtc2dwYWNrXzEuZGVjb2RlKShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaGFuZGxlIHN0cmluZ3MgYXMgcGxhaW4gSlNPTiBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEcm9wIG1lc3NhZ2VzIHRoYXQgYXJlIG5vdCByZWxhdGVkIHRvIHRoZSBhY3R1YWwgcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIGZ1dHVyZSwgd2UgbWlnaHQgd2FudCB0byBoYW5kbGUgb3RoZXIgdHlwZXMgb2YgbWVzc2FnZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzcGVjaWZ5IHRoZSBmYWwgd3MgcHJvdG9jb2wgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmF1dGhvcml6ZWRFcnJvcihkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInVuYXV0aG9yaXplZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiVW5hdXRob3JpemVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N1Y2Nlc3NmdWxSZXN1bHQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlc3VsdChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGYWxFcnJvclJlc3VsdChkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yID09PSBcIlRJTUVPVVRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaW1lb3V0IGVycm9yIG1lc3NhZ2VzIGp1c3QgaW5kaWNhdGUgdGhhdCB0aGUgY29ubmVjdGlvbiBoYXNuJ3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjZWl2ZWQgYW4gaW5jb21pbmcgbWVzc2FnZSBmb3IgYSB3aGlsZS4gV2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhlbSBhcyBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvbkVycm9yID0gbm9vcCB9ID0gZ2V0Q2FsbGJhY2tzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihuZXcgcmVzcG9uc2VfMS5BcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke2RhdGEuZXJyb3J9OiAke2RhdGEucmVhc29ufWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYmV0dGVyIGVycm9yIHN0YXR1cyBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzU3RhdGUgPSBtYWNoaW5lLmN1cnJlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNlbmQgPSAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhyb3R0bGVkIHNlbmQgdG8gYXZvaWQgc2VuZGluZyB0b28gbWFueSBtZXNzYWdlc1xuICAgICAgICAgICAgICAgIHN0YXRlTWFjaGluZS50aHJvdHRsZWRTZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGlucHV0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlTWFjaGluZS5zZW5kKHsgdHlwZTogXCJjbG9zZVwiIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VuZCxcbiAgICAgICAgICAgICAgICBjbG9zZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWx0aW1lLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/realtime.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/request.js":
/*!****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/request.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dispatchRequest = dispatchRequest;\nexports.buildUrl = buildUrl;\nconst retry_1 = __webpack_require__(/*! ./retry */ \"(rsc)/./node_modules/@fal-ai/client/src/retry.js\");\nconst runtime_1 = __webpack_require__(/*! ./runtime */ \"(rsc)/./node_modules/@fal-ai/client/src/runtime.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@fal-ai/client/src/utils.js\");\nconst isCloudflareWorkers = typeof navigator !== \"undefined\" &&\n    (navigator === null || navigator === void 0 ? void 0 : navigator.userAgent) === \"Cloudflare-Workers\";\nfunction dispatchRequest(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        const { targetUrl, input, config, options = {} } = params;\n        const { credentials: credentialsValue, requestMiddleware, responseHandler, fetch, } = config;\n        const retryOptions = Object.assign(Object.assign({}, config.retry), (options.retry || {}));\n        const executeRequest = () => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            const userAgent = (0, runtime_1.isBrowser)() ? {} : { \"User-Agent\": (0, runtime_1.getUserAgent)() };\n            const credentials = typeof credentialsValue === \"function\"\n                ? credentialsValue()\n                : credentialsValue;\n            const { method, url, headers } = yield requestMiddleware({\n                method: ((_b = (_a = params.method) !== null && _a !== void 0 ? _a : options.method) !== null && _b !== void 0 ? _b : \"post\").toUpperCase(),\n                url: targetUrl,\n                headers: params.headers,\n            });\n            const authHeader = credentials\n                ? { Authorization: `Key ${credentials}` }\n                : {};\n            const requestHeaders = Object.assign(Object.assign(Object.assign(Object.assign({}, authHeader), { Accept: \"application/json\", \"Content-Type\": \"application/json\" }), userAgent), (headers !== null && headers !== void 0 ? headers : {}));\n            const { responseHandler: customResponseHandler, retry: _ } = options, requestInit = __rest(options, [\"responseHandler\", \"retry\"]);\n            const response = yield fetch(url, Object.assign(Object.assign(Object.assign(Object.assign({}, requestInit), { method, headers: Object.assign(Object.assign({}, requestHeaders), ((_c = requestInit.headers) !== null && _c !== void 0 ? _c : {})) }), (!isCloudflareWorkers && { mode: \"cors\" })), { signal: options.signal, body: method.toLowerCase() !== \"get\" && input\n                    ? JSON.stringify(input)\n                    : undefined }));\n            const handleResponse = customResponseHandler !== null && customResponseHandler !== void 0 ? customResponseHandler : responseHandler;\n            return yield handleResponse(response);\n        });\n        let lastError;\n        for (let attempt = 0; attempt <= retryOptions.maxRetries; attempt++) {\n            try {\n                return yield executeRequest();\n            }\n            catch (error) {\n                lastError = error;\n                const shouldNotRetry = attempt === retryOptions.maxRetries ||\n                    !(0, retry_1.isRetryableError)(error, retryOptions.retryableStatusCodes) ||\n                    ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted);\n                if (shouldNotRetry) {\n                    throw error;\n                }\n                const delay = (0, retry_1.calculateBackoffDelay)(attempt, retryOptions.baseDelay, retryOptions.maxDelay, retryOptions.backoffMultiplier, retryOptions.enableJitter);\n                yield (0, utils_1.sleep)(delay);\n            }\n        }\n        throw lastError;\n    });\n}\n/**\n * Builds the final url to run the function based on its `id` or alias and\n * a the options from `RunOptions<Input>`.\n *\n * @private\n * @param id the function id or alias\n * @param options the run options\n * @returns the final url to run the function\n */\nfunction buildUrl(id, options = {}) {\n    var _a, _b;\n    const method = ((_a = options.method) !== null && _a !== void 0 ? _a : \"post\").toLowerCase();\n    const path = ((_b = options.path) !== null && _b !== void 0 ? _b : \"\").replace(/^\\//, \"\").replace(/\\/{2,}/, \"/\");\n    const input = options.input;\n    const params = Object.assign(Object.assign({}, (options.query || {})), (method === \"get\" ? input : {}));\n    const queryParams = Object.keys(params).length > 0\n        ? `?${new URLSearchParams(params).toString()}`\n        : \"\";\n    // if a fal url is passed, just use it\n    if ((0, utils_1.isValidUrl)(id)) {\n        const url = id.endsWith(\"/\") ? id : `${id}/`;\n        return `${url}${path}${queryParams}`;\n    }\n    const appId = (0, utils_1.ensureEndpointIdFormat)(id);\n    const subdomain = options.subdomain ? `${options.subdomain}.` : \"\";\n    const url = `https://${subdomain}fal.run/${appId}/${path}`;\n    return `${url.replace(/\\/$/, \"\")}${queryParams}`;\n}\n//# sourceMappingURL=request.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3JlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQixnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxxRUFBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RCxnQkFBZ0IsNEVBQTRFO0FBQzVGLDJEQUEyRCxxQ0FBcUM7QUFDaEc7QUFDQTtBQUNBLDhEQUE4RCxJQUFJO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CLHNCQUFzQixZQUFZO0FBQ3REO0FBQ0EsNkZBQTZGLGlCQUFpQixnRUFBZ0UscUVBQXFFO0FBQ25QLG9CQUFvQixtREFBbUQ7QUFDdkUsd0dBQXdHLGtCQUFrQiwrQ0FBK0Msa0ZBQWtGLElBQUksOEJBQThCLGNBQWMsTUFBTTtBQUNqVDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsMEdBQTBHLEdBQUc7QUFDN0c7QUFDQSxpREFBaUQsc0JBQXNCLGtDQUFrQztBQUN6RztBQUNBLGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxHQUFHO0FBQ2xELGtCQUFrQixJQUFJLEVBQUUsS0FBSyxFQUFFLFlBQVk7QUFDM0M7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0QsMkJBQTJCLFVBQVUsVUFBVSxNQUFNLEdBQUcsS0FBSztBQUM3RCxjQUFjLHVCQUF1QixFQUFFLFlBQVk7QUFDbkQ7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NlYW4vZnV0dXJlL25vZGVfbW9kdWxlcy9AZmFsLWFpL2NsaWVudC9zcmMvcmVxdWVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kaXNwYXRjaFJlcXVlc3QgPSBkaXNwYXRjaFJlcXVlc3Q7XG5leHBvcnRzLmJ1aWxkVXJsID0gYnVpbGRVcmw7XG5jb25zdCByZXRyeV8xID0gcmVxdWlyZShcIi4vcmV0cnlcIik7XG5jb25zdCBydW50aW1lXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgaXNDbG91ZGZsYXJlV29ya2VycyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLnVzZXJBZ2VudCkgPT09IFwiQ2xvdWRmbGFyZS1Xb3JrZXJzXCI7XG5mdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QocGFyYW1zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHRhcmdldFVybCwgaW5wdXQsIGNvbmZpZywgb3B0aW9ucyA9IHt9IH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHsgY3JlZGVudGlhbHM6IGNyZWRlbnRpYWxzVmFsdWUsIHJlcXVlc3RNaWRkbGV3YXJlLCByZXNwb25zZUhhbmRsZXIsIGZldGNoLCB9ID0gY29uZmlnO1xuICAgICAgICBjb25zdCByZXRyeU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZy5yZXRyeSksIChvcHRpb25zLnJldHJ5IHx8IHt9KSk7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGVSZXF1ZXN0ID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCB1c2VyQWdlbnQgPSAoMCwgcnVudGltZV8xLmlzQnJvd3NlcikoKSA/IHt9IDogeyBcIlVzZXItQWdlbnRcIjogKDAsIHJ1bnRpbWVfMS5nZXRVc2VyQWdlbnQpKCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gdHlwZW9mIGNyZWRlbnRpYWxzVmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgID8gY3JlZGVudGlhbHNWYWx1ZSgpXG4gICAgICAgICAgICAgICAgOiBjcmVkZW50aWFsc1ZhbHVlO1xuICAgICAgICAgICAgY29uc3QgeyBtZXRob2QsIHVybCwgaGVhZGVycyB9ID0geWllbGQgcmVxdWVzdE1pZGRsZXdhcmUoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogKChfYiA9IChfYSA9IHBhcmFtcy5tZXRob2QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdGlvbnMubWV0aG9kKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcInBvc3RcIikudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICB1cmw6IHRhcmdldFVybCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBwYXJhbXMuaGVhZGVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYXV0aEhlYWRlciA9IGNyZWRlbnRpYWxzXG4gICAgICAgICAgICAgICAgPyB7IEF1dGhvcml6YXRpb246IGBLZXkgJHtjcmVkZW50aWFsc31gIH1cbiAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhdXRoSGVhZGVyKSwgeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KSwgdXNlckFnZW50KSwgKGhlYWRlcnMgIT09IG51bGwgJiYgaGVhZGVycyAhPT0gdm9pZCAwID8gaGVhZGVycyA6IHt9KSk7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3BvbnNlSGFuZGxlcjogY3VzdG9tUmVzcG9uc2VIYW5kbGVyLCByZXRyeTogXyB9ID0gb3B0aW9ucywgcmVxdWVzdEluaXQgPSBfX3Jlc3Qob3B0aW9ucywgW1wicmVzcG9uc2VIYW5kbGVyXCIsIFwicmV0cnlcIl0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaCh1cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RJbml0KSwgeyBtZXRob2QsIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdEhlYWRlcnMpLCAoKF9jID0gcmVxdWVzdEluaXQuaGVhZGVycykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30pKSB9KSwgKCFpc0Nsb3VkZmxhcmVXb3JrZXJzICYmIHsgbW9kZTogXCJjb3JzXCIgfSkpLCB7IHNpZ25hbDogb3B0aW9ucy5zaWduYWwsIGJvZHk6IG1ldGhvZC50b0xvd2VyQ2FzZSgpICE9PSBcImdldFwiICYmIGlucHV0XG4gICAgICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoaW5wdXQpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gY3VzdG9tUmVzcG9uc2VIYW5kbGVyICE9PSBudWxsICYmIGN1c3RvbVJlc3BvbnNlSGFuZGxlciAhPT0gdm9pZCAwID8gY3VzdG9tUmVzcG9uc2VIYW5kbGVyIDogcmVzcG9uc2VIYW5kbGVyO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsYXN0RXJyb3I7XG4gICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDw9IHJldHJ5T3B0aW9ucy5tYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGV4ZWN1dGVSZXF1ZXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGROb3RSZXRyeSA9IGF0dGVtcHQgPT09IHJldHJ5T3B0aW9ucy5tYXhSZXRyaWVzIHx8XG4gICAgICAgICAgICAgICAgICAgICEoMCwgcmV0cnlfMS5pc1JldHJ5YWJsZUVycm9yKShlcnJvciwgcmV0cnlPcHRpb25zLnJldHJ5YWJsZVN0YXR1c0NvZGVzKSB8fFxuICAgICAgICAgICAgICAgICAgICAoKF9hID0gb3B0aW9ucy5zaWduYWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hYm9ydGVkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTm90UmV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gKDAsIHJldHJ5XzEuY2FsY3VsYXRlQmFja29mZkRlbGF5KShhdHRlbXB0LCByZXRyeU9wdGlvbnMuYmFzZURlbGF5LCByZXRyeU9wdGlvbnMubWF4RGVsYXksIHJldHJ5T3B0aW9ucy5iYWNrb2ZmTXVsdGlwbGllciwgcmV0cnlPcHRpb25zLmVuYWJsZUppdHRlcik7XG4gICAgICAgICAgICAgICAgeWllbGQgKDAsIHV0aWxzXzEuc2xlZXApKGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBsYXN0RXJyb3I7XG4gICAgfSk7XG59XG4vKipcbiAqIEJ1aWxkcyB0aGUgZmluYWwgdXJsIHRvIHJ1biB0aGUgZnVuY3Rpb24gYmFzZWQgb24gaXRzIGBpZGAgb3IgYWxpYXMgYW5kXG4gKiBhIHRoZSBvcHRpb25zIGZyb20gYFJ1bk9wdGlvbnM8SW5wdXQ+YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGlkIHRoZSBmdW5jdGlvbiBpZCBvciBhbGlhc1xuICogQHBhcmFtIG9wdGlvbnMgdGhlIHJ1biBvcHRpb25zXG4gKiBAcmV0dXJucyB0aGUgZmluYWwgdXJsIHRvIHJ1biB0aGUgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gYnVpbGRVcmwoaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgbWV0aG9kID0gKChfYSA9IG9wdGlvbnMubWV0aG9kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcInBvc3RcIikudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBwYXRoID0gKChfYiA9IG9wdGlvbnMucGF0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIikucmVwbGFjZSgvXlxcLy8sIFwiXCIpLnJlcGxhY2UoL1xcL3syLH0vLCBcIi9cIik7XG4gICAgY29uc3QgaW5wdXQgPSBvcHRpb25zLmlucHV0O1xuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKG9wdGlvbnMucXVlcnkgfHwge30pKSwgKG1ldGhvZCA9PT0gXCJnZXRcIiA/IGlucHV0IDoge30pKTtcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID4gMFxuICAgICAgICA/IGA/JHtuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykudG9TdHJpbmcoKX1gXG4gICAgICAgIDogXCJcIjtcbiAgICAvLyBpZiBhIGZhbCB1cmwgaXMgcGFzc2VkLCBqdXN0IHVzZSBpdFxuICAgIGlmICgoMCwgdXRpbHNfMS5pc1ZhbGlkVXJsKShpZCkpIHtcbiAgICAgICAgY29uc3QgdXJsID0gaWQuZW5kc1dpdGgoXCIvXCIpID8gaWQgOiBgJHtpZH0vYDtcbiAgICAgICAgcmV0dXJuIGAke3VybH0ke3BhdGh9JHtxdWVyeVBhcmFtc31gO1xuICAgIH1cbiAgICBjb25zdCBhcHBJZCA9ICgwLCB1dGlsc18xLmVuc3VyZUVuZHBvaW50SWRGb3JtYXQpKGlkKTtcbiAgICBjb25zdCBzdWJkb21haW4gPSBvcHRpb25zLnN1YmRvbWFpbiA/IGAke29wdGlvbnMuc3ViZG9tYWlufS5gIDogXCJcIjtcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly8ke3N1YmRvbWFpbn1mYWwucnVuLyR7YXBwSWR9LyR7cGF0aH1gO1xuICAgIHJldHVybiBgJHt1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpfSR7cXVlcnlQYXJhbXN9YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3QuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/response.js":
/*!*****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/response.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ValidationError = exports.ApiError = void 0;\nexports.defaultResponseHandler = defaultResponseHandler;\nexports.resultResponseHandler = resultResponseHandler;\nconst REQUEST_ID_HEADER = \"x-fal-request-id\";\nclass ApiError extends Error {\n    constructor({ message, status, body }) {\n        super(message);\n        this.name = \"ApiError\";\n        this.status = status;\n        this.body = body;\n    }\n}\nexports.ApiError = ApiError;\nclass ValidationError extends ApiError {\n    constructor(args) {\n        super(args);\n        this.name = \"ValidationError\";\n    }\n    get fieldErrors() {\n        // NOTE: this is a hack to support both FastAPI/Pydantic errors\n        // and some custom 422 errors that might not be in the Pydantic format.\n        if (typeof this.body.detail === \"string\") {\n            return [\n                {\n                    loc: [\"body\"],\n                    msg: this.body.detail,\n                    type: \"value_error\",\n                },\n            ];\n        }\n        return this.body.detail || [];\n    }\n    getFieldErrors(field) {\n        return this.fieldErrors.filter((error) => error.loc[error.loc.length - 1] === field);\n    }\n}\nexports.ValidationError = ValidationError;\nfunction defaultResponseHandler(response) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        const { status, statusText } = response;\n        const contentType = (_a = response.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"\";\n        if (!response.ok) {\n            if (contentType.includes(\"application/json\")) {\n                const body = yield response.json();\n                const ErrorType = status === 422 ? ValidationError : ApiError;\n                throw new ErrorType({\n                    message: body.message || statusText,\n                    status,\n                    body,\n                });\n            }\n            throw new ApiError({ message: `HTTP ${status}: ${statusText}`, status });\n        }\n        if (contentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        if (contentType.includes(\"text/html\")) {\n            return response.text();\n        }\n        if (contentType.includes(\"application/octet-stream\")) {\n            return response.arrayBuffer();\n        }\n        // TODO convert to either number or bool automatically\n        return response.text();\n    });\n}\nfunction resultResponseHandler(response) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const data = yield defaultResponseHandler(response);\n        return {\n            data,\n            requestId: response.headers.get(REQUEST_ID_HEADER) || \"\",\n        };\n    });\n}\n//# sourceMappingURL=response.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3Jlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxnQkFBZ0I7QUFDMUMsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUNBQWlDLGlCQUFpQixPQUFPLElBQUksV0FBVyxXQUFXO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zZWFuL2Z1dHVyZS9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3Jlc3BvbnNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGV4cG9ydHMuQXBpRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmRlZmF1bHRSZXNwb25zZUhhbmRsZXIgPSBkZWZhdWx0UmVzcG9uc2VIYW5kbGVyO1xuZXhwb3J0cy5yZXN1bHRSZXNwb25zZUhhbmRsZXIgPSByZXN1bHRSZXNwb25zZUhhbmRsZXI7XG5jb25zdCBSRVFVRVNUX0lEX0hFQURFUiA9IFwieC1mYWwtcmVxdWVzdC1pZFwiO1xuY2xhc3MgQXBpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlLCBzdGF0dXMsIGJvZHkgfSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBcGlFcnJvclwiO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB9XG59XG5leHBvcnRzLkFwaUVycm9yID0gQXBpRXJyb3I7XG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBBcGlFcnJvciB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICBzdXBlcihhcmdzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJWYWxpZGF0aW9uRXJyb3JcIjtcbiAgICB9XG4gICAgZ2V0IGZpZWxkRXJyb3JzKCkge1xuICAgICAgICAvLyBOT1RFOiB0aGlzIGlzIGEgaGFjayB0byBzdXBwb3J0IGJvdGggRmFzdEFQSS9QeWRhbnRpYyBlcnJvcnNcbiAgICAgICAgLy8gYW5kIHNvbWUgY3VzdG9tIDQyMiBlcnJvcnMgdGhhdCBtaWdodCBub3QgYmUgaW4gdGhlIFB5ZGFudGljIGZvcm1hdC5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmJvZHkuZGV0YWlsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jOiBbXCJib2R5XCJdLFxuICAgICAgICAgICAgICAgICAgICBtc2c6IHRoaXMuYm9keS5kZXRhaWwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidmFsdWVfZXJyb3JcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ib2R5LmRldGFpbCB8fCBbXTtcbiAgICB9XG4gICAgZ2V0RmllbGRFcnJvcnMoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRFcnJvcnMuZmlsdGVyKChlcnJvcikgPT4gZXJyb3IubG9jW2Vycm9yLmxvYy5sZW5ndGggLSAxXSA9PT0gZmllbGQpO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yO1xuZnVuY3Rpb24gZGVmYXVsdFJlc3BvbnNlSGFuZGxlcihyZXNwb25zZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIHN0YXR1c1RleHQgfSA9IHJlc3BvbnNlO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IChfYSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBFcnJvclR5cGUgPSBzdGF0dXMgPT09IDQyMiA/IFZhbGlkYXRpb25FcnJvciA6IEFwaUVycm9yO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvclR5cGUoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBib2R5Lm1lc3NhZ2UgfHwgc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKHsgbWVzc2FnZTogYEhUVFAgJHtzdGF0dXN9OiAke3N0YXR1c1RleHR9YCwgc3RhdHVzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwidGV4dC9odG1sXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBjb252ZXJ0IHRvIGVpdGhlciBudW1iZXIgb3IgYm9vbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXN1bHRSZXNwb25zZUhhbmRsZXIocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBkYXRhID0geWllbGQgZGVmYXVsdFJlc3BvbnNlSGFuZGxlcihyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVxdWVzdElkOiByZXNwb25zZS5oZWFkZXJzLmdldChSRVFVRVNUX0lEX0hFQURFUikgfHwgXCJcIixcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3BvbnNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/retry.js":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/retry.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_RETRY_OPTIONS = exports.DEFAULT_RETRYABLE_STATUS_CODES = void 0;\nexports.isRetryableError = isRetryableError;\nexports.calculateBackoffDelay = calculateBackoffDelay;\nexports.executeWithRetry = executeWithRetry;\nconst response_1 = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/@fal-ai/client/src/response.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@fal-ai/client/src/utils.js\");\n/**\n * Base retryable status codes for most requests\n */\nexports.DEFAULT_RETRYABLE_STATUS_CODES = [429, 502, 503, 504];\nexports.DEFAULT_RETRY_OPTIONS = {\n    maxRetries: 3,\n    baseDelay: 1000,\n    maxDelay: 30000,\n    backoffMultiplier: 2,\n    retryableStatusCodes: exports.DEFAULT_RETRYABLE_STATUS_CODES,\n    enableJitter: true,\n};\n/**\n * Determines if an error is retryable based on the status code\n */\nfunction isRetryableError(error, retryableStatusCodes) {\n    return (error instanceof response_1.ApiError && retryableStatusCodes.includes(error.status));\n}\n/**\n * Calculates the backoff delay for a given attempt using exponential backoff\n */\nfunction calculateBackoffDelay(attempt, baseDelay, maxDelay, backoffMultiplier, enableJitter) {\n    const exponentialDelay = Math.min(baseDelay * Math.pow(backoffMultiplier, attempt), maxDelay);\n    if (enableJitter) {\n        // Add 25% jitter to prevent thundering herd\n        const jitter = 0.25 * exponentialDelay * (Math.random() * 2 - 1);\n        return Math.max(0, exponentialDelay + jitter);\n    }\n    return exponentialDelay;\n}\n/**\n * Executes an operation with retry logic and returns both result and metrics\n */\nfunction executeWithRetry(operation, options, onRetry) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const metrics = {\n            totalAttempts: 0,\n            totalDelay: 0,\n        };\n        let lastError;\n        for (let attempt = 0; attempt <= options.maxRetries; attempt++) {\n            metrics.totalAttempts++;\n            try {\n                const result = yield operation();\n                return { result, metrics };\n            }\n            catch (error) {\n                lastError = error;\n                metrics.lastError = error;\n                if (attempt === options.maxRetries ||\n                    !isRetryableError(error, options.retryableStatusCodes)) {\n                    throw error;\n                }\n                const delay = calculateBackoffDelay(attempt, options.baseDelay, options.maxDelay, options.backoffMultiplier, options.enableJitter);\n                metrics.totalDelay += delay;\n                if (onRetry) {\n                    onRetry(attempt + 1, error, delay);\n                }\n                yield (0, utils_1.sleep)(delay);\n            }\n        }\n        throw lastError;\n    });\n}\n//# sourceMappingURL=retry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3JldHJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxzQ0FBc0M7QUFDdEUsd0JBQXdCO0FBQ3hCLDZCQUE2QjtBQUM3Qix3QkFBd0I7QUFDeEIsbUJBQW1CLG1CQUFPLENBQUMsdUVBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2Vhbi9mdXR1cmUvbm9kZV9tb2R1bGVzL0BmYWwtYWkvY2xpZW50L3NyYy9yZXRyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX1JFVFJZX09QVElPTlMgPSBleHBvcnRzLkRFRkFVTFRfUkVUUllBQkxFX1NUQVRVU19DT0RFUyA9IHZvaWQgMDtcbmV4cG9ydHMuaXNSZXRyeWFibGVFcnJvciA9IGlzUmV0cnlhYmxlRXJyb3I7XG5leHBvcnRzLmNhbGN1bGF0ZUJhY2tvZmZEZWxheSA9IGNhbGN1bGF0ZUJhY2tvZmZEZWxheTtcbmV4cG9ydHMuZXhlY3V0ZVdpdGhSZXRyeSA9IGV4ZWN1dGVXaXRoUmV0cnk7XG5jb25zdCByZXNwb25zZV8xID0gcmVxdWlyZShcIi4vcmVzcG9uc2VcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIEJhc2UgcmV0cnlhYmxlIHN0YXR1cyBjb2RlcyBmb3IgbW9zdCByZXF1ZXN0c1xuICovXG5leHBvcnRzLkRFRkFVTFRfUkVUUllBQkxFX1NUQVRVU19DT0RFUyA9IFs0MjksIDUwMiwgNTAzLCA1MDRdO1xuZXhwb3J0cy5ERUZBVUxUX1JFVFJZX09QVElPTlMgPSB7XG4gICAgbWF4UmV0cmllczogMyxcbiAgICBiYXNlRGVsYXk6IDEwMDAsXG4gICAgbWF4RGVsYXk6IDMwMDAwLFxuICAgIGJhY2tvZmZNdWx0aXBsaWVyOiAyLFxuICAgIHJldHJ5YWJsZVN0YXR1c0NvZGVzOiBleHBvcnRzLkRFRkFVTFRfUkVUUllBQkxFX1NUQVRVU19DT0RFUyxcbiAgICBlbmFibGVKaXR0ZXI6IHRydWUsXG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGFuIGVycm9yIGlzIHJldHJ5YWJsZSBiYXNlZCBvbiB0aGUgc3RhdHVzIGNvZGVcbiAqL1xuZnVuY3Rpb24gaXNSZXRyeWFibGVFcnJvcihlcnJvciwgcmV0cnlhYmxlU3RhdHVzQ29kZXMpIHtcbiAgICByZXR1cm4gKGVycm9yIGluc3RhbmNlb2YgcmVzcG9uc2VfMS5BcGlFcnJvciAmJiByZXRyeWFibGVTdGF0dXNDb2Rlcy5pbmNsdWRlcyhlcnJvci5zdGF0dXMpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYmFja29mZiBkZWxheSBmb3IgYSBnaXZlbiBhdHRlbXB0IHVzaW5nIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQmFja29mZkRlbGF5KGF0dGVtcHQsIGJhc2VEZWxheSwgbWF4RGVsYXksIGJhY2tvZmZNdWx0aXBsaWVyLCBlbmFibGVKaXR0ZXIpIHtcbiAgICBjb25zdCBleHBvbmVudGlhbERlbGF5ID0gTWF0aC5taW4oYmFzZURlbGF5ICogTWF0aC5wb3coYmFja29mZk11bHRpcGxpZXIsIGF0dGVtcHQpLCBtYXhEZWxheSk7XG4gICAgaWYgKGVuYWJsZUppdHRlcikge1xuICAgICAgICAvLyBBZGQgwrEyNSUgaml0dGVyIHRvIHByZXZlbnQgdGh1bmRlcmluZyBoZXJkXG4gICAgICAgIGNvbnN0IGppdHRlciA9IDAuMjUgKiBleHBvbmVudGlhbERlbGF5ICogKE1hdGgucmFuZG9tKCkgKiAyIC0gMSk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBleHBvbmVudGlhbERlbGF5ICsgaml0dGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9uZW50aWFsRGVsYXk7XG59XG4vKipcbiAqIEV4ZWN1dGVzIGFuIG9wZXJhdGlvbiB3aXRoIHJldHJ5IGxvZ2ljIGFuZCByZXR1cm5zIGJvdGggcmVzdWx0IGFuZCBtZXRyaWNzXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVXaXRoUmV0cnkob3BlcmF0aW9uLCBvcHRpb25zLCBvblJldHJ5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgbWV0cmljcyA9IHtcbiAgICAgICAgICAgIHRvdGFsQXR0ZW1wdHM6IDAsXG4gICAgICAgICAgICB0b3RhbERlbGF5OiAwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgbGFzdEVycm9yO1xuICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8PSBvcHRpb25zLm1heFJldHJpZXM7IGF0dGVtcHQrKykge1xuICAgICAgICAgICAgbWV0cmljcy50b3RhbEF0dGVtcHRzKys7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIG9wZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdCwgbWV0cmljcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgbWV0cmljcy5sYXN0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA9PT0gb3B0aW9ucy5tYXhSZXRyaWVzIHx8XG4gICAgICAgICAgICAgICAgICAgICFpc1JldHJ5YWJsZUVycm9yKGVycm9yLCBvcHRpb25zLnJldHJ5YWJsZVN0YXR1c0NvZGVzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBjYWxjdWxhdGVCYWNrb2ZmRGVsYXkoYXR0ZW1wdCwgb3B0aW9ucy5iYXNlRGVsYXksIG9wdGlvbnMubWF4RGVsYXksIG9wdGlvbnMuYmFja29mZk11bHRpcGxpZXIsIG9wdGlvbnMuZW5hYmxlSml0dGVyKTtcbiAgICAgICAgICAgICAgICBtZXRyaWNzLnRvdGFsRGVsYXkgKz0gZGVsYXk7XG4gICAgICAgICAgICAgICAgaWYgKG9uUmV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgb25SZXRyeShhdHRlbXB0ICsgMSwgZXJyb3IsIGRlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQgKDAsIHV0aWxzXzEuc2xlZXApKGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBsYXN0RXJyb3I7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/retry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/runtime.js":
/*!****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/runtime.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/* eslint-disable @typescript-eslint/no-var-requires */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isBrowser = isBrowser;\nexports.getUserAgent = getUserAgent;\nfunction isBrowser() {\n    return (typeof window !== \"undefined\" && typeof window.document !== \"undefined\");\n}\nlet memoizedUserAgent = null;\nfunction getUserAgent() {\n    if (memoizedUserAgent !== null) {\n        return memoizedUserAgent;\n    }\n    const packageInfo = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/@fal-ai/client/package.json\");\n    memoizedUserAgent = `${packageInfo.name}/${packageInfo.version}`;\n    return memoizedUserAgent;\n}\n//# sourceMappingURL=runtime.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3J1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyx5RUFBaUI7QUFDakQsMkJBQTJCLGlCQUFpQixHQUFHLG9CQUFvQjtBQUNuRTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zZWFuL2Z1dHVyZS9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQnJvd3NlciA9IGlzQnJvd3NlcjtcbmV4cG9ydHMuZ2V0VXNlckFnZW50ID0gZ2V0VXNlckFnZW50O1xuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKTtcbn1cbmxldCBtZW1vaXplZFVzZXJBZ2VudCA9IG51bGw7XG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gICAgaWYgKG1lbW9pemVkVXNlckFnZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtZW1vaXplZFVzZXJBZ2VudDtcbiAgICB9XG4gICAgY29uc3QgcGFja2FnZUluZm8gPSByZXF1aXJlKFwiLi4vcGFja2FnZS5qc29uXCIpO1xuICAgIG1lbW9pemVkVXNlckFnZW50ID0gYCR7cGFja2FnZUluZm8ubmFtZX0vJHtwYWNrYWdlSW5mby52ZXJzaW9ufWA7XG4gICAgcmV0dXJuIG1lbW9pemVkVXNlckFnZW50O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVudGltZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/runtime.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/storage.js":
/*!****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/storage.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createStorageClient = createStorageClient;\nconst config_1 = __webpack_require__(/*! ./config */ \"(rsc)/./node_modules/@fal-ai/client/src/config.js\");\nconst request_1 = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/@fal-ai/client/src/request.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@fal-ai/client/src/utils.js\");\n/**\n * Get the file extension from the content type. This is used to generate\n * a file name if the file name is not provided.\n *\n * @param contentType the content type of the file.\n * @returns the file extension or `bin` if the content type is not recognized.\n */\nfunction getExtensionFromContentType(contentType) {\n    var _a;\n    const [_, fileType] = contentType.split(\"/\");\n    return (_a = fileType.split(/[-;]/)[0]) !== null && _a !== void 0 ? _a : \"bin\";\n}\n/**\n * Initiate the upload of a file to the server. This returns the URL to upload\n * the file to and the URL of the file once it is uploaded.\n */\nfunction initiateUpload(file, config, contentType) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const filename = file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;\n        return yield (0, request_1.dispatchRequest)({\n            method: \"POST\",\n            // NOTE: We want to test V3 without making it the default at the API level\n            targetUrl: `${(0, config_1.getRestApiUrl)()}/storage/upload/initiate?storage_type=fal-cdn-v3`,\n            input: {\n                content_type: contentType,\n                file_name: filename,\n            },\n            config,\n        });\n    });\n}\n/**\n * Initiate the multipart upload of a file to the server. This returns the URL to upload\n * the file to and the URL of the file once it is uploaded.\n */\nfunction initiateMultipartUpload(file, config, contentType) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const filename = file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;\n        return yield (0, request_1.dispatchRequest)({\n            method: \"POST\",\n            targetUrl: `${(0, config_1.getRestApiUrl)()}/storage/upload/initiate-multipart?storage_type=fal-cdn-v3`,\n            input: {\n                content_type: contentType,\n                file_name: filename,\n            },\n            config,\n        });\n    });\n}\nfunction partUploadRetries(uploadUrl_1, chunk_1, config_2) {\n    return __awaiter(this, arguments, void 0, function* (uploadUrl, chunk, config, tries = 3) {\n        if (tries === 0) {\n            throw new Error(\"Part upload failed, retries exhausted\");\n        }\n        const { fetch, responseHandler } = config;\n        try {\n            const response = yield fetch(uploadUrl, {\n                method: \"PUT\",\n                body: chunk,\n            });\n            return (yield responseHandler(response));\n        }\n        catch (error) {\n            return yield partUploadRetries(uploadUrl, chunk, config, tries - 1);\n        }\n    });\n}\nfunction multipartUpload(file, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { fetch, responseHandler } = config;\n        const contentType = file.type || \"application/octet-stream\";\n        const { upload_url: uploadUrl, file_url: url } = yield initiateMultipartUpload(file, config, contentType);\n        // Break the file into 10MB chunks\n        const chunkSize = 10 * 1024 * 1024;\n        const chunks = Math.ceil(file.size / chunkSize);\n        const parsedUrl = new URL(uploadUrl);\n        const responses = [];\n        for (let i = 0; i < chunks; i++) {\n            const start = i * chunkSize;\n            const end = Math.min(start + chunkSize, file.size);\n            const chunk = file.slice(start, end);\n            const partNumber = i + 1;\n            // {uploadUrl}/{part_number}?uploadUrlParams=...\n            const partUploadUrl = `${parsedUrl.origin}${parsedUrl.pathname}/${partNumber}${parsedUrl.search}`;\n            responses.push(yield partUploadRetries(partUploadUrl, chunk, config));\n        }\n        // Complete the upload\n        const completeUrl = `${parsedUrl.origin}${parsedUrl.pathname}/complete${parsedUrl.search}`;\n        const response = yield fetch(completeUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                parts: responses.map((mpart) => ({\n                    partNumber: mpart.partNumber,\n                    etag: mpart.etag,\n                })),\n            }),\n        });\n        yield responseHandler(response);\n        return url;\n    });\n}\nfunction createStorageClient({ config, }) {\n    const ref = {\n        upload: (file) => __awaiter(this, void 0, void 0, function* () {\n            // Check for 90+ MB file size to do multipart upload\n            if (file.size > 90 * 1024 * 1024) {\n                return yield multipartUpload(file, config);\n            }\n            const contentType = file.type || \"application/octet-stream\";\n            const { fetch, responseHandler } = config;\n            const { upload_url: uploadUrl, file_url: url } = yield initiateUpload(file, config, contentType);\n            const response = yield fetch(uploadUrl, {\n                method: \"PUT\",\n                body: file,\n                headers: {\n                    \"Content-Type\": file.type || \"application/octet-stream\",\n                },\n            });\n            yield responseHandler(response);\n            return url;\n        }),\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        transformInput: (input) => __awaiter(this, void 0, void 0, function* () {\n            if (Array.isArray(input)) {\n                return Promise.all(input.map((item) => ref.transformInput(item)));\n            }\n            else if (input instanceof Blob) {\n                return yield ref.upload(input);\n            }\n            else if ((0, utils_1.isPlainObject)(input)) {\n                const inputObject = input;\n                const promises = Object.entries(inputObject).map((_a) => __awaiter(this, [_a], void 0, function* ([key, value]) {\n                    return [key, yield ref.transformInput(value)];\n                }));\n                const results = yield Promise.all(promises);\n                return Object.fromEntries(results);\n            }\n            // Return the input as is if it's neither an object nor a file/blob/data URI\n            return input;\n        }),\n    };\n    return ref;\n}\n//# sourceMappingURL=storage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3N0b3JhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyxtRUFBVTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxxRUFBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXLEdBQUcseUNBQXlDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXLEdBQUcseUNBQXlDO0FBQ2hHO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVLEVBQUUsWUFBWTtBQUN4QyxxQ0FBcUMsaUJBQWlCLEVBQUUsbUJBQW1CLEdBQUcsV0FBVyxFQUFFLGlCQUFpQjtBQUM1RztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCLEVBQUUsbUJBQW1CLFdBQVcsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zZWFuL2Z1dHVyZS9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3N0b3JhZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlU3RvcmFnZUNsaWVudCA9IGNyZWF0ZVN0b3JhZ2VDbGllbnQ7XG5jb25zdCBjb25maWdfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcbmNvbnN0IHJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuL3JlcXVlc3RcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIEdldCB0aGUgZmlsZSBleHRlbnNpb24gZnJvbSB0aGUgY29udGVudCB0eXBlLiBUaGlzIGlzIHVzZWQgdG8gZ2VuZXJhdGVcbiAqIGEgZmlsZSBuYW1lIGlmIHRoZSBmaWxlIG5hbWUgaXMgbm90IHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSBjb250ZW50VHlwZSB0aGUgY29udGVudCB0eXBlIG9mIHRoZSBmaWxlLlxuICogQHJldHVybnMgdGhlIGZpbGUgZXh0ZW5zaW9uIG9yIGBiaW5gIGlmIHRoZSBjb250ZW50IHR5cGUgaXMgbm90IHJlY29nbml6ZWQuXG4gKi9cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbkZyb21Db250ZW50VHlwZShjb250ZW50VHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBbXywgZmlsZVR5cGVdID0gY29udGVudFR5cGUuc3BsaXQoXCIvXCIpO1xuICAgIHJldHVybiAoX2EgPSBmaWxlVHlwZS5zcGxpdCgvWy07XS8pWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcImJpblwiO1xufVxuLyoqXG4gKiBJbml0aWF0ZSB0aGUgdXBsb2FkIG9mIGEgZmlsZSB0byB0aGUgc2VydmVyLiBUaGlzIHJldHVybnMgdGhlIFVSTCB0byB1cGxvYWRcbiAqIHRoZSBmaWxlIHRvIGFuZCB0aGUgVVJMIG9mIHRoZSBmaWxlIG9uY2UgaXQgaXMgdXBsb2FkZWQuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYXRlVXBsb2FkKGZpbGUsIGNvbmZpZywgY29udGVudFR5cGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGZpbGUubmFtZSB8fCBgJHtEYXRlLm5vdygpfS4ke2dldEV4dGVuc2lvbkZyb21Db250ZW50VHlwZShjb250ZW50VHlwZSl9YDtcbiAgICAgICAgcmV0dXJuIHlpZWxkICgwLCByZXF1ZXN0XzEuZGlzcGF0Y2hSZXF1ZXN0KSh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgLy8gTk9URTogV2Ugd2FudCB0byB0ZXN0IFYzIHdpdGhvdXQgbWFraW5nIGl0IHRoZSBkZWZhdWx0IGF0IHRoZSBBUEkgbGV2ZWxcbiAgICAgICAgICAgIHRhcmdldFVybDogYCR7KDAsIGNvbmZpZ18xLmdldFJlc3RBcGlVcmwpKCl9L3N0b3JhZ2UvdXBsb2FkL2luaXRpYXRlP3N0b3JhZ2VfdHlwZT1mYWwtY2RuLXYzYCxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgY29udGVudF90eXBlOiBjb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBmaWxlX25hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIEluaXRpYXRlIHRoZSBtdWx0aXBhcnQgdXBsb2FkIG9mIGEgZmlsZSB0byB0aGUgc2VydmVyLiBUaGlzIHJldHVybnMgdGhlIFVSTCB0byB1cGxvYWRcbiAqIHRoZSBmaWxlIHRvIGFuZCB0aGUgVVJMIG9mIHRoZSBmaWxlIG9uY2UgaXQgaXMgdXBsb2FkZWQuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYXRlTXVsdGlwYXJ0VXBsb2FkKGZpbGUsIGNvbmZpZywgY29udGVudFR5cGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGZpbGUubmFtZSB8fCBgJHtEYXRlLm5vdygpfS4ke2dldEV4dGVuc2lvbkZyb21Db250ZW50VHlwZShjb250ZW50VHlwZSl9YDtcbiAgICAgICAgcmV0dXJuIHlpZWxkICgwLCByZXF1ZXN0XzEuZGlzcGF0Y2hSZXF1ZXN0KSh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgdGFyZ2V0VXJsOiBgJHsoMCwgY29uZmlnXzEuZ2V0UmVzdEFwaVVybCkoKX0vc3RvcmFnZS91cGxvYWQvaW5pdGlhdGUtbXVsdGlwYXJ0P3N0b3JhZ2VfdHlwZT1mYWwtY2RuLXYzYCxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgY29udGVudF90eXBlOiBjb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBmaWxlX25hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0VXBsb2FkUmV0cmllcyh1cGxvYWRVcmxfMSwgY2h1bmtfMSwgY29uZmlnXzIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKHVwbG9hZFVybCwgY2h1bmssIGNvbmZpZywgdHJpZXMgPSAzKSB7XG4gICAgICAgIGlmICh0cmllcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFydCB1cGxvYWQgZmFpbGVkLCByZXRyaWVzIGV4aGF1c3RlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGZldGNoLCByZXNwb25zZUhhbmRsZXIgfSA9IGNvbmZpZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2godXBsb2FkVXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IGNodW5rLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKHlpZWxkIHJlc3BvbnNlSGFuZGxlcihyZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHBhcnRVcGxvYWRSZXRyaWVzKHVwbG9hZFVybCwgY2h1bmssIGNvbmZpZywgdHJpZXMgLSAxKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gbXVsdGlwYXJ0VXBsb2FkKGZpbGUsIGNvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHsgZmV0Y2gsIHJlc3BvbnNlSGFuZGxlciB9ID0gY29uZmlnO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGZpbGUudHlwZSB8fCBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICBjb25zdCB7IHVwbG9hZF91cmw6IHVwbG9hZFVybCwgZmlsZV91cmw6IHVybCB9ID0geWllbGQgaW5pdGlhdGVNdWx0aXBhcnRVcGxvYWQoZmlsZSwgY29uZmlnLCBjb250ZW50VHlwZSk7XG4gICAgICAgIC8vIEJyZWFrIHRoZSBmaWxlIGludG8gMTBNQiBjaHVua3NcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gMTAgKiAxMDI0ICogMTAyNDtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gTWF0aC5jZWlsKGZpbGUuc2l6ZSAvIGNodW5rU2l6ZSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXBsb2FkVXJsKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSAqIGNodW5rU2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgY2h1bmtTaXplLCBmaWxlLnNpemUpO1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBmaWxlLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgY29uc3QgcGFydE51bWJlciA9IGkgKyAxO1xuICAgICAgICAgICAgLy8ge3VwbG9hZFVybH0ve3BhcnRfbnVtYmVyfT91cGxvYWRVcmxQYXJhbXM9Li4uXG4gICAgICAgICAgICBjb25zdCBwYXJ0VXBsb2FkVXJsID0gYCR7cGFyc2VkVXJsLm9yaWdpbn0ke3BhcnNlZFVybC5wYXRobmFtZX0vJHtwYXJ0TnVtYmVyfSR7cGFyc2VkVXJsLnNlYXJjaH1gO1xuICAgICAgICAgICAgcmVzcG9uc2VzLnB1c2goeWllbGQgcGFydFVwbG9hZFJldHJpZXMocGFydFVwbG9hZFVybCwgY2h1bmssIGNvbmZpZykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXBsZXRlIHRoZSB1cGxvYWRcbiAgICAgICAgY29uc3QgY29tcGxldGVVcmwgPSBgJHtwYXJzZWRVcmwub3JpZ2lufSR7cGFyc2VkVXJsLnBhdGhuYW1lfS9jb21wbGV0ZSR7cGFyc2VkVXJsLnNlYXJjaH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKGNvbXBsZXRlVXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBwYXJ0czogcmVzcG9uc2VzLm1hcCgobXBhcnQpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHBhcnROdW1iZXI6IG1wYXJ0LnBhcnROdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIGV0YWc6IG1wYXJ0LmV0YWcsXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgICB5aWVsZCByZXNwb25zZUhhbmRsZXIocmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RvcmFnZUNsaWVudCh7IGNvbmZpZywgfSkge1xuICAgIGNvbnN0IHJlZiA9IHtcbiAgICAgICAgdXBsb2FkOiAoZmlsZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIDkwKyBNQiBmaWxlIHNpemUgdG8gZG8gbXVsdGlwYXJ0IHVwbG9hZFxuICAgICAgICAgICAgaWYgKGZpbGUuc2l6ZSA+IDkwICogMTAyNCAqIDEwMjQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgbXVsdGlwYXJ0VXBsb2FkKGZpbGUsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGZpbGUudHlwZSB8fCBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICAgICAgY29uc3QgeyBmZXRjaCwgcmVzcG9uc2VIYW5kbGVyIH0gPSBjb25maWc7XG4gICAgICAgICAgICBjb25zdCB7IHVwbG9hZF91cmw6IHVwbG9hZFVybCwgZmlsZV91cmw6IHVybCB9ID0geWllbGQgaW5pdGlhdGVVcGxvYWQoZmlsZSwgY29uZmlnLCBjb250ZW50VHlwZSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKHVwbG9hZFVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgICAgICBib2R5OiBmaWxlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogZmlsZS50eXBlIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeWllbGQgcmVzcG9uc2VIYW5kbGVyKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH0pLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0cmFuc2Zvcm1JbnB1dDogKGlucHV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaW5wdXQubWFwKChpdGVtKSA9PiByZWYudHJhbnNmb3JtSW5wdXQoaXRlbSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCByZWYudXBsb2FkKGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzUGxhaW5PYmplY3QpKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0T2JqZWN0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBPYmplY3QuZW50cmllcyhpbnB1dE9iamVjdCkubWFwKChfYSkgPT4gX19hd2FpdGVyKHRoaXMsIFtfYV0sIHZvaWQgMCwgZnVuY3Rpb24qIChba2V5LCB2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtrZXksIHlpZWxkIHJlZi50cmFuc2Zvcm1JbnB1dCh2YWx1ZSldO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0geWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGlucHV0IGFzIGlzIGlmIGl0J3MgbmVpdGhlciBhbiBvYmplY3Qgbm9yIGEgZmlsZS9ibG9iL2RhdGEgVVJJXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH0pLFxuICAgIH07XG4gICAgcmV0dXJuIHJlZjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0b3JhZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/storage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/streaming.js":
/*!******************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/streaming.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FalStream = void 0;\nexports.createStreamingClient = createStreamingClient;\nconst eventsource_parser_1 = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.cjs\");\nconst auth_1 = __webpack_require__(/*! ./auth */ \"(rsc)/./node_modules/@fal-ai/client/src/auth.js\");\nconst request_1 = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/@fal-ai/client/src/request.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/@fal-ai/client/src/response.js\");\nconst CONTENT_TYPE_EVENT_STREAM = \"text/event-stream\";\nconst EVENT_STREAM_TIMEOUT = 15 * 1000;\n/**\n * The class representing a streaming response. With t\n */\nclass FalStream {\n    constructor(endpointId, config, options) {\n        var _a;\n        // support for event listeners\n        this.listeners = new Map();\n        this.buffer = [];\n        // local state\n        this.currentData = undefined;\n        this.lastEventTimestamp = 0;\n        this.streamClosed = false;\n        this._requestId = null;\n        this.abortController = new AbortController();\n        this.start = () => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const { endpointId, options } = this;\n            const { input, method = \"post\", connectionMode = \"server\" } = options;\n            try {\n                if (connectionMode === \"client\") {\n                    // if we are in the browser, we need to get a temporary token\n                    // to authenticate the request\n                    const token = yield (0, auth_1.getTemporaryAuthToken)(endpointId, this.config);\n                    const { fetch } = this.config;\n                    const parsedUrl = new URL(this.url);\n                    parsedUrl.searchParams.set(\"fal_jwt_token\", token);\n                    const response = yield fetch(parsedUrl.toString(), {\n                        method: method.toUpperCase(),\n                        headers: {\n                            accept: (_a = options.accept) !== null && _a !== void 0 ? _a : CONTENT_TYPE_EVENT_STREAM,\n                            \"content-type\": \"application/json\",\n                        },\n                        body: input && method !== \"get\" ? JSON.stringify(input) : undefined,\n                        signal: this.abortController.signal,\n                    });\n                    this._requestId = response.headers.get(\"x-fal-request-id\");\n                    return yield this.handleResponse(response);\n                }\n                return yield (0, request_1.dispatchRequest)({\n                    method: method.toUpperCase(),\n                    targetUrl: this.url,\n                    input,\n                    config: this.config,\n                    options: {\n                        headers: {\n                            accept: (_b = options.accept) !== null && _b !== void 0 ? _b : CONTENT_TYPE_EVENT_STREAM,\n                        },\n                        responseHandler: (response) => __awaiter(this, void 0, void 0, function* () {\n                            this._requestId = response.headers.get(\"x-fal-request-id\");\n                            return yield this.handleResponse(response);\n                        }),\n                        signal: this.abortController.signal,\n                    },\n                });\n            }\n            catch (error) {\n                this.handleError(error);\n            }\n        });\n        this.handleResponse = (response) => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (!response.ok) {\n                try {\n                    // we know the response failed, call the response handler\n                    // so the exception gets converted to ApiError correctly\n                    yield (0, response_1.defaultResponseHandler)(response);\n                }\n                catch (error) {\n                    this.emit(\"error\", error);\n                }\n                return;\n            }\n            const body = response.body;\n            if (!body) {\n                this.emit(\"error\", new response_1.ApiError({\n                    message: \"Response body is empty.\",\n                    status: 400,\n                    body: undefined,\n                }));\n                return;\n            }\n            const isEventStream = ((_a = response.headers.get(\"content-type\")) !== null && _a !== void 0 ? _a : \"\").startsWith(CONTENT_TYPE_EVENT_STREAM);\n            // any response that is not a text/event-stream will be handled as a binary stream\n            if (!isEventStream) {\n                const reader = body.getReader();\n                const emitRawChunk = () => {\n                    reader.read().then(({ done, value }) => {\n                        if (done) {\n                            this.emit(\"done\", this.currentData);\n                            return;\n                        }\n                        this.currentData = value;\n                        this.emit(\"data\", value);\n                        emitRawChunk();\n                    });\n                };\n                emitRawChunk();\n                return;\n            }\n            const decoder = new TextDecoder(\"utf-8\");\n            const reader = response.body.getReader();\n            const parser = (0, eventsource_parser_1.createParser)((event) => {\n                if (event.type === \"event\") {\n                    const data = event.data;\n                    try {\n                        const parsedData = JSON.parse(data);\n                        this.buffer.push(parsedData);\n                        this.currentData = parsedData;\n                        this.emit(\"data\", parsedData);\n                        // also emit 'message'for backwards compatibility\n                        this.emit(\"message\", parsedData);\n                    }\n                    catch (e) {\n                        this.emit(\"error\", e);\n                    }\n                }\n            });\n            const timeout = (_b = this.options.timeout) !== null && _b !== void 0 ? _b : EVENT_STREAM_TIMEOUT;\n            const readPartialResponse = () => __awaiter(this, void 0, void 0, function* () {\n                const { value, done } = yield reader.read();\n                this.lastEventTimestamp = Date.now();\n                parser.feed(decoder.decode(value));\n                if (Date.now() - this.lastEventTimestamp > timeout) {\n                    this.emit(\"error\", new response_1.ApiError({\n                        message: `Event stream timed out after ${(timeout / 1000).toFixed(0)} seconds with no messages.`,\n                        status: 408,\n                    }));\n                }\n                if (!done) {\n                    readPartialResponse().catch(this.handleError);\n                }\n                else {\n                    this.emit(\"done\", this.currentData);\n                }\n            });\n            readPartialResponse().catch(this.handleError);\n            return;\n        });\n        this.handleError = (error) => {\n            var _a;\n            // In case AbortError is thrown but the signal is marked as aborted\n            // it means the user called abort() and we should not emit an error\n            // as it's expected behavior\n            // See note on: https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort\n            if (error.name === \"AbortError\" || this.signal.aborted) {\n                return;\n            }\n            const apiError = error instanceof response_1.ApiError\n                ? error\n                : new response_1.ApiError({\n                    message: (_a = error.message) !== null && _a !== void 0 ? _a : \"An unknown error occurred\",\n                    status: 500,\n                });\n            this.emit(\"error\", apiError);\n            return;\n        };\n        this.on = (type, listener) => {\n            var _a;\n            if (!this.listeners.has(type)) {\n                this.listeners.set(type, []);\n            }\n            (_a = this.listeners.get(type)) === null || _a === void 0 ? void 0 : _a.push(listener);\n        };\n        this.emit = (type, event) => {\n            const listeners = this.listeners.get(type) || [];\n            for (const listener of listeners) {\n                listener(event);\n            }\n        };\n        /**\n         * Gets a reference to the `Promise` that indicates whether the streaming\n         * is done or not. Developers should always call this in their apps to ensure\n         * the request is over.\n         *\n         * An alternative to this, is to use `on('done')` in case your application\n         * architecture works best with event listeners.\n         *\n         * @returns the promise that resolves when the request is done.\n         */\n        this.done = () => __awaiter(this, void 0, void 0, function* () { return this.donePromise; });\n        /**\n         * Aborts the streaming request.\n         *\n         * **Note:** This method is noop in case the request is already done.\n         *\n         * @param reason optional cause for aborting the request.\n         */\n        this.abort = (reason) => {\n            if (!this.streamClosed) {\n                this.abortController.abort(reason);\n            }\n        };\n        this.endpointId = endpointId;\n        this.config = config;\n        this.url =\n            (_a = options.url) !== null && _a !== void 0 ? _a : (0, request_1.buildUrl)(endpointId, {\n                path: \"/stream\",\n                query: options.queryParams,\n            });\n        this.options = options;\n        this.donePromise = new Promise((resolve, reject) => {\n            if (this.streamClosed) {\n                reject(new response_1.ApiError({\n                    message: \"Streaming connection is already closed.\",\n                    status: 400,\n                    body: undefined,\n                }));\n            }\n            this.signal.addEventListener(\"abort\", () => {\n                var _a;\n                resolve((_a = this.currentData) !== null && _a !== void 0 ? _a : {});\n            });\n            this.on(\"done\", (data) => {\n                this.streamClosed = true;\n                resolve(data);\n            });\n            this.on(\"error\", (error) => {\n                this.streamClosed = true;\n                reject(error);\n            });\n        });\n        // if a abort signal was passed, sync it with the internal one\n        if (options.signal) {\n            options.signal.addEventListener(\"abort\", () => {\n                this.abortController.abort();\n            });\n        }\n        // start the streaming request\n        this.start().catch(this.handleError);\n    }\n    [Symbol.asyncIterator]() {\n        return __asyncGenerator(this, arguments, function* _a() {\n            let running = true;\n            const stopAsyncIterator = () => (running = false);\n            this.on(\"error\", stopAsyncIterator);\n            this.on(\"done\", stopAsyncIterator);\n            while (running || this.buffer.length > 0) {\n                const data = this.buffer.shift();\n                if (data) {\n                    yield yield __await(data);\n                }\n                // the short timeout ensures the while loop doesn't block other\n                // frames getting executed concurrently\n                yield __await(new Promise((resolve) => setTimeout(resolve, 16)));\n            }\n        });\n    }\n    /**\n     * Gets the `AbortSignal` instance that can be used to listen for abort events.\n     *\n     * **Note:** this signal is internal to the `FalStream` instance. If you pass your\n     * own abort signal, the `FalStream` will listen to it and abort it appropriately.\n     *\n     * @returns the `AbortSignal` instance.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\n     */\n    get signal() {\n        return this.abortController.signal;\n    }\n    /**\n     * Gets the request id of the streaming request.\n     *\n     * @returns the request id.\n     */\n    get requestId() {\n        return this._requestId;\n    }\n}\nexports.FalStream = FalStream;\nfunction createStreamingClient({ config, storage, }) {\n    return {\n        stream(endpointId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const input = options.input\n                    ? yield storage.transformInput(options.input)\n                    : undefined;\n                return new FalStream(endpointId, config, Object.assign(Object.assign({}, options), { input: input }));\n            });\n        },\n    };\n}\n//# sourceMappingURL=streaming.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3N0cmVhbWluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9HQUFvRyxjQUFjO0FBQ25JLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLDZCQUE2QjtBQUM3Qiw2QkFBNkIsbUJBQU8sQ0FBQyxrRkFBb0I7QUFDekQsZUFBZSxtQkFBTyxDQUFDLCtEQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFXO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQyxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNkJBQTZCO0FBQzlGO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDBCQUEwQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixjQUFjLGNBQWM7QUFDbkgsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zZWFuL2Z1dHVyZS9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3N0cmVhbWluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fYXdhaXQgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXQpIHx8IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpOyB9XG52YXIgX19hc3luY0dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19hc3luY0dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmFsU3RyZWFtID0gdm9pZCAwO1xuZXhwb3J0cy5jcmVhdGVTdHJlYW1pbmdDbGllbnQgPSBjcmVhdGVTdHJlYW1pbmdDbGllbnQ7XG5jb25zdCBldmVudHNvdXJjZV9wYXJzZXJfMSA9IHJlcXVpcmUoXCJldmVudHNvdXJjZS1wYXJzZXJcIik7XG5jb25zdCBhdXRoXzEgPSByZXF1aXJlKFwiLi9hdXRoXCIpO1xuY29uc3QgcmVxdWVzdF8xID0gcmVxdWlyZShcIi4vcmVxdWVzdFwiKTtcbmNvbnN0IHJlc3BvbnNlXzEgPSByZXF1aXJlKFwiLi9yZXNwb25zZVwiKTtcbmNvbnN0IENPTlRFTlRfVFlQRV9FVkVOVF9TVFJFQU0gPSBcInRleHQvZXZlbnQtc3RyZWFtXCI7XG5jb25zdCBFVkVOVF9TVFJFQU1fVElNRU9VVCA9IDE1ICogMTAwMDtcbi8qKlxuICogVGhlIGNsYXNzIHJlcHJlc2VudGluZyBhIHN0cmVhbWluZyByZXNwb25zZS4gV2l0aCB0XG4gKi9cbmNsYXNzIEZhbFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoZW5kcG9pbnRJZCwgY29uZmlnLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gc3VwcG9ydCBmb3IgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICAvLyBsb2NhbCBzdGF0ZVxuICAgICAgICB0aGlzLmN1cnJlbnREYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxhc3RFdmVudFRpbWVzdGFtcCA9IDA7XG4gICAgICAgIHRoaXMuc3RyZWFtQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kcG9pbnRJZCwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgaW5wdXQsIG1ldGhvZCA9IFwicG9zdFwiLCBjb25uZWN0aW9uTW9kZSA9IFwic2VydmVyXCIgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uTW9kZSA9PT0gXCJjbGllbnRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgaW4gdGhlIGJyb3dzZXIsIHdlIG5lZWQgdG8gZ2V0IGEgdGVtcG9yYXJ5IHRva2VuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGF1dGhlbnRpY2F0ZSB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHlpZWxkICgwLCBhdXRoXzEuZ2V0VGVtcG9yYXJ5QXV0aFRva2VuKShlbmRwb2ludElkLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmV0Y2ggfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHRoaXMudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJmYWxfand0X3Rva2VuXCIsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaChwYXJzZWRVcmwudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHQ6IChfYSA9IG9wdGlvbnMuYWNjZXB0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBDT05URU5UX1RZUEVfRVZFTlRfU1RSRUFNLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGlucHV0ICYmIG1ldGhvZCAhPT0gXCJnZXRcIiA/IEpTT04uc3RyaW5naWZ5KGlucHV0KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdElkID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LWZhbC1yZXF1ZXN0LWlkXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCAoMCwgcmVxdWVzdF8xLmRpc3BhdGNoUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRVcmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdDogKF9iID0gb3B0aW9ucy5hY2NlcHQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IENPTlRFTlRfVFlQRV9FVkVOVF9TVFJFQU0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyOiAocmVzcG9uc2UpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWQgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtZmFsLXJlcXVlc3QtaWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNwb25zZSA9IChyZXNwb25zZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IHRoZSByZXNwb25zZSBmYWlsZWQsIGNhbGwgdGhlIHJlc3BvbnNlIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhlIGV4Y2VwdGlvbiBnZXRzIGNvbnZlcnRlZCB0byBBcGlFcnJvciBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgKDAsIHJlc3BvbnNlXzEuZGVmYXVsdFJlc3BvbnNlSGFuZGxlcikocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyByZXNwb25zZV8xLkFwaUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJSZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDQwMCxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0V2ZW50U3RyZWFtID0gKChfYSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiKS5zdGFydHNXaXRoKENPTlRFTlRfVFlQRV9FVkVOVF9TVFJFQU0pO1xuICAgICAgICAgICAgLy8gYW55IHJlc3BvbnNlIHRoYXQgaXMgbm90IGEgdGV4dC9ldmVudC1zdHJlYW0gd2lsbCBiZSBoYW5kbGVkIGFzIGEgYmluYXJ5IHN0cmVhbVxuICAgICAgICAgICAgaWYgKCFpc0V2ZW50U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWl0UmF3Q2h1bmsgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkKCkudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRvbmVcIiwgdGhpcy5jdXJyZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RGF0YSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGF0YVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0UmF3Q2h1bmsoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBlbWl0UmF3Q2h1bmsoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gKDAsIGV2ZW50c291cmNlX3BhcnNlcl8xLmNyZWF0ZVBhcnNlcikoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiZXZlbnRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChwYXJzZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGEgPSBwYXJzZWREYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGF0YVwiLCBwYXJzZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gZW1pdCAnbWVzc2FnZSdmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgcGFyc2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gKF9iID0gdGhpcy5vcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IEVWRU5UX1NUUkVBTV9USU1FT1VUO1xuICAgICAgICAgICAgY29uc3QgcmVhZFBhcnRpYWxSZXNwb25zZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSB5aWVsZCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdEV2ZW50VGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBwYXJzZXIuZmVlZChkZWNvZGVyLmRlY29kZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5sYXN0RXZlbnRUaW1lc3RhbXAgPiB0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyByZXNwb25zZV8xLkFwaUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBFdmVudCBzdHJlYW0gdGltZWQgb3V0IGFmdGVyICR7KHRpbWVvdXQgLyAxMDAwKS50b0ZpeGVkKDApfSBzZWNvbmRzIHdpdGggbm8gbWVzc2FnZXMuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNDA4LFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkUGFydGlhbFJlc3BvbnNlKCkuY2F0Y2godGhpcy5oYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkb25lXCIsIHRoaXMuY3VycmVudERhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVhZFBhcnRpYWxSZXNwb25zZSgpLmNhdGNoKHRoaXMuaGFuZGxlRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBBYm9ydEVycm9yIGlzIHRocm93biBidXQgdGhlIHNpZ25hbCBpcyBtYXJrZWQgYXMgYWJvcnRlZFxuICAgICAgICAgICAgLy8gaXQgbWVhbnMgdGhlIHVzZXIgY2FsbGVkIGFib3J0KCkgYW5kIHdlIHNob3VsZCBub3QgZW1pdCBhbiBlcnJvclxuICAgICAgICAgICAgLy8gYXMgaXQncyBleHBlY3RlZCBiZWhhdmlvclxuICAgICAgICAgICAgLy8gU2VlIG5vdGUgb246IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BYm9ydENvbnRyb2xsZXIvYWJvcnRcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIiB8fCB0aGlzLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpRXJyb3IgPSBlcnJvciBpbnN0YW5jZW9mIHJlc3BvbnNlXzEuQXBpRXJyb3JcbiAgICAgICAgICAgICAgICA/IGVycm9yXG4gICAgICAgICAgICAgICAgOiBuZXcgcmVzcG9uc2VfMS5BcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChfYSA9IGVycm9yLm1lc3NhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZFwiLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGFwaUVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbiA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxpc3RlbmVycy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5zZXQodHlwZSwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcnMuZ2V0KHR5cGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdCA9ICh0eXBlLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMuZ2V0KHR5cGUpIHx8IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBgUHJvbWlzZWAgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RyZWFtaW5nXG4gICAgICAgICAqIGlzIGRvbmUgb3Igbm90LiBEZXZlbG9wZXJzIHNob3VsZCBhbHdheXMgY2FsbCB0aGlzIGluIHRoZWlyIGFwcHMgdG8gZW5zdXJlXG4gICAgICAgICAqIHRoZSByZXF1ZXN0IGlzIG92ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIHRoaXMsIGlzIHRvIHVzZSBgb24oJ2RvbmUnKWAgaW4gY2FzZSB5b3VyIGFwcGxpY2F0aW9uXG4gICAgICAgICAqIGFyY2hpdGVjdHVyZSB3b3JrcyBiZXN0IHdpdGggZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHJlcXVlc3QgaXMgZG9uZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG9uZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIHRoaXMuZG9uZVByb21pc2U7IH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWJvcnRzIHRoZSBzdHJlYW1pbmcgcmVxdWVzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIG5vb3AgaW4gY2FzZSB0aGUgcmVxdWVzdCBpcyBhbHJlYWR5IGRvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByZWFzb24gb3B0aW9uYWwgY2F1c2UgZm9yIGFib3J0aW5nIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hYm9ydCA9IChyZWFzb24pID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdHJlYW1DbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydChyZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVuZHBvaW50SWQgPSBlbmRwb2ludElkO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy51cmwgPVxuICAgICAgICAgICAgKF9hID0gb3B0aW9ucy51cmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICgwLCByZXF1ZXN0XzEuYnVpbGRVcmwpKGVuZHBvaW50SWQsIHtcbiAgICAgICAgICAgICAgICBwYXRoOiBcIi9zdHJlYW1cIixcbiAgICAgICAgICAgICAgICBxdWVyeTogb3B0aW9ucy5xdWVyeVBhcmFtcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmRvbmVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyByZXNwb25zZV8xLkFwaUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJTdHJlYW1pbmcgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGNsb3NlZC5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiA0MDAsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKChfYSA9IHRoaXMuY3VycmVudERhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vbihcImRvbmVcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbUNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpZiBhIGFib3J0IHNpZ25hbCB3YXMgcGFzc2VkLCBzeW5jIGl0IHdpdGggdGhlIGludGVybmFsIG9uZVxuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0YXJ0IHRoZSBzdHJlYW1pbmcgcmVxdWVzdFxuICAgICAgICB0aGlzLnN0YXJ0KCkuY2F0Y2godGhpcy5oYW5kbGVFcnJvcik7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIF9hKCkge1xuICAgICAgICAgICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qgc3RvcEFzeW5jSXRlcmF0b3IgPSAoKSA9PiAocnVubmluZyA9IGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMub24oXCJlcnJvclwiLCBzdG9wQXN5bmNJdGVyYXRvcik7XG4gICAgICAgICAgICB0aGlzLm9uKFwiZG9uZVwiLCBzdG9wQXN5bmNJdGVyYXRvcik7XG4gICAgICAgICAgICB3aGlsZSAocnVubmluZyB8fCB0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuYnVmZmVyLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGhlIHNob3J0IHRpbWVvdXQgZW5zdXJlcyB0aGUgd2hpbGUgbG9vcCBkb2Vzbid0IGJsb2NrIG90aGVyXG4gICAgICAgICAgICAgICAgLy8gZnJhbWVzIGdldHRpbmcgZXhlY3V0ZWQgY29uY3VycmVudGx5XG4gICAgICAgICAgICAgICAgeWllbGQgX19hd2FpdChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxNikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGBBYm9ydFNpZ25hbGAgaW5zdGFuY2UgdGhhdCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gZm9yIGFib3J0IGV2ZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiB0aGlzIHNpZ25hbCBpcyBpbnRlcm5hbCB0byB0aGUgYEZhbFN0cmVhbWAgaW5zdGFuY2UuIElmIHlvdSBwYXNzIHlvdXJcbiAgICAgKiBvd24gYWJvcnQgc2lnbmFsLCB0aGUgYEZhbFN0cmVhbWAgd2lsbCBsaXN0ZW4gdG8gaXQgYW5kIGFib3J0IGl0IGFwcHJvcHJpYXRlbHkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgYEFib3J0U2lnbmFsYCBpbnN0YW5jZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BYm9ydFNpZ25hbFxuICAgICAqL1xuICAgIGdldCBzaWduYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJlcXVlc3QgaWQgb2YgdGhlIHN0cmVhbWluZyByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIHJlcXVlc3QgaWQuXG4gICAgICovXG4gICAgZ2V0IHJlcXVlc3RJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RJZDtcbiAgICB9XG59XG5leHBvcnRzLkZhbFN0cmVhbSA9IEZhbFN0cmVhbTtcbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWluZ0NsaWVudCh7IGNvbmZpZywgc3RvcmFnZSwgfSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbShlbmRwb2ludElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gb3B0aW9ucy5pbnB1dFxuICAgICAgICAgICAgICAgICAgICA/IHlpZWxkIHN0b3JhZ2UudHJhbnNmb3JtSW5wdXQob3B0aW9ucy5pbnB1dClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxTdHJlYW0oZW5kcG9pbnRJZCwgY29uZmlnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGlucHV0OiBpbnB1dCB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyZWFtaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/streaming.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/types/common.js":
/*!*********************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/types/common.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isQueueStatus = isQueueStatus;\nexports.isCompletedQueueStatus = isCompletedQueueStatus;\nfunction isQueueStatus(obj) {\n    return obj && obj.status && obj.response_url;\n}\nfunction isCompletedQueueStatus(obj) {\n    return isQueueStatus(obj) && obj.status === \"COMPLETED\";\n}\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3R5cGVzL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2Vhbi9mdXR1cmUvbm9kZV9tb2R1bGVzL0BmYWwtYWkvY2xpZW50L3NyYy90eXBlcy9jb21tb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzUXVldWVTdGF0dXMgPSBpc1F1ZXVlU3RhdHVzO1xuZXhwb3J0cy5pc0NvbXBsZXRlZFF1ZXVlU3RhdHVzID0gaXNDb21wbGV0ZWRRdWV1ZVN0YXR1cztcbmZ1bmN0aW9uIGlzUXVldWVTdGF0dXMob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouc3RhdHVzICYmIG9iai5yZXNwb25zZV91cmw7XG59XG5mdW5jdGlvbiBpc0NvbXBsZXRlZFF1ZXVlU3RhdHVzKG9iaikge1xuICAgIHJldHVybiBpc1F1ZXVlU3RhdHVzKG9iaikgJiYgb2JqLnN0YXR1cyA9PT0gXCJDT01QTEVURURcIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/types/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/utils.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ensureEndpointIdFormat = ensureEndpointIdFormat;\nexports.parseEndpointId = parseEndpointId;\nexports.isValidUrl = isValidUrl;\nexports.throttle = throttle;\nexports.isReact = isReact;\nexports.isPlainObject = isPlainObject;\nexports.sleep = sleep;\nfunction ensureEndpointIdFormat(id) {\n    const parts = id.split(\"/\");\n    if (parts.length > 1) {\n        return id;\n    }\n    const [, appOwner, appId] = /^([0-9]+)-([a-zA-Z0-9-]+)$/.exec(id) || [];\n    if (appOwner && appId) {\n        return `${appOwner}/${appId}`;\n    }\n    throw new Error(`Invalid app id: ${id}. Must be in the format <appOwner>/<appId>`);\n}\nconst ENDPOINT_NAMESPACES = [\"workflows\", \"comfy\"];\nfunction parseEndpointId(id) {\n    const normalizedId = ensureEndpointIdFormat(id);\n    const parts = normalizedId.split(\"/\");\n    if (ENDPOINT_NAMESPACES.includes(parts[0])) {\n        return {\n            owner: parts[1],\n            alias: parts[2],\n            path: parts.slice(3).join(\"/\") || undefined,\n            namespace: parts[0],\n        };\n    }\n    return {\n        owner: parts[0],\n        alias: parts[1],\n        path: parts.slice(2).join(\"/\") || undefined,\n    };\n}\nfunction isValidUrl(url) {\n    try {\n        const { host } = new URL(url);\n        return /(fal\\.(ai|run))$/.test(host);\n    }\n    catch (_) {\n        return false;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction throttle(func, limit, leading = false) {\n    let lastFunc;\n    let lastRan;\n    return (...args) => {\n        if (!lastRan && leading) {\n            func(...args);\n            lastRan = Date.now();\n        }\n        else {\n            if (lastFunc) {\n                clearTimeout(lastFunc);\n            }\n            lastFunc = setTimeout(() => {\n                if (Date.now() - lastRan >= limit) {\n                    func(...args);\n                    lastRan = Date.now();\n                }\n            }, limit - (Date.now() - lastRan));\n        }\n    };\n}\nlet isRunningInReact;\n/**\n * Not really the most optimal way to detect if we're running in React,\n * but the idea here is that we can support multiple rendering engines\n * (starting with React), with all their peculiarities, without having\n * to add a dependency or creating custom integrations (e.g. custom hooks).\n *\n * Yes, a bit of magic to make things works out-of-the-box.\n * @returns `true` if running in React, `false` otherwise.\n */\nfunction isReact() {\n    if (isRunningInReact === undefined) {\n        const stack = new Error().stack;\n        isRunningInReact =\n            !!stack &&\n                (stack.includes(\"node_modules/react-dom/\") ||\n                    stack.includes(\"node_modules/next/\"));\n    }\n    return isRunningInReact;\n}\n/**\n * Check if a value is a plain object.\n * @param value - The value to check.\n * @returns `true` if the value is a plain object, `false` otherwise.\n */\nfunction isPlainObject(value) {\n    return !!value && Object.getPrototypeOf(value) === Object.prototype;\n}\n/**\n * Utility function to sleep for a given number of milliseconds\n */\nfunction sleep(ms) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    });\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUyxHQUFHLE1BQU07QUFDcEM7QUFDQSx1Q0FBdUMsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NlYW4vZnV0dXJlL25vZGVfbW9kdWxlcy9AZmFsLWFpL2NsaWVudC9zcmMvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5zdXJlRW5kcG9pbnRJZEZvcm1hdCA9IGVuc3VyZUVuZHBvaW50SWRGb3JtYXQ7XG5leHBvcnRzLnBhcnNlRW5kcG9pbnRJZCA9IHBhcnNlRW5kcG9pbnRJZDtcbmV4cG9ydHMuaXNWYWxpZFVybCA9IGlzVmFsaWRVcmw7XG5leHBvcnRzLnRocm90dGxlID0gdGhyb3R0bGU7XG5leHBvcnRzLmlzUmVhY3QgPSBpc1JlYWN0O1xuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbmV4cG9ydHMuc2xlZXAgPSBzbGVlcDtcbmZ1bmN0aW9uIGVuc3VyZUVuZHBvaW50SWRGb3JtYXQoaWQpIHtcbiAgICBjb25zdCBwYXJ0cyA9IGlkLnNwbGl0KFwiL1wiKTtcbiAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIGNvbnN0IFssIGFwcE93bmVyLCBhcHBJZF0gPSAvXihbMC05XSspLShbYS16QS1aMC05LV0rKSQvLmV4ZWMoaWQpIHx8IFtdO1xuICAgIGlmIChhcHBPd25lciAmJiBhcHBJZCkge1xuICAgICAgICByZXR1cm4gYCR7YXBwT3duZXJ9LyR7YXBwSWR9YDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFwcCBpZDogJHtpZH0uIE11c3QgYmUgaW4gdGhlIGZvcm1hdCA8YXBwT3duZXI+LzxhcHBJZD5gKTtcbn1cbmNvbnN0IEVORFBPSU5UX05BTUVTUEFDRVMgPSBbXCJ3b3JrZmxvd3NcIiwgXCJjb21meVwiXTtcbmZ1bmN0aW9uIHBhcnNlRW5kcG9pbnRJZChpZCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRJZCA9IGVuc3VyZUVuZHBvaW50SWRGb3JtYXQoaWQpO1xuICAgIGNvbnN0IHBhcnRzID0gbm9ybWFsaXplZElkLnNwbGl0KFwiL1wiKTtcbiAgICBpZiAoRU5EUE9JTlRfTkFNRVNQQUNFUy5pbmNsdWRlcyhwYXJ0c1swXSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG93bmVyOiBwYXJ0c1sxXSxcbiAgICAgICAgICAgIGFsaWFzOiBwYXJ0c1syXSxcbiAgICAgICAgICAgIHBhdGg6IHBhcnRzLnNsaWNlKDMpLmpvaW4oXCIvXCIpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogcGFydHNbMF0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG93bmVyOiBwYXJ0c1swXSxcbiAgICAgICAgYWxpYXM6IHBhcnRzWzFdLFxuICAgICAgICBwYXRoOiBwYXJ0cy5zbGljZSgyKS5qb2luKFwiL1wiKSB8fCB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRVcmwodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSBuZXcgVVJMKHVybCk7XG4gICAgICAgIHJldHVybiAvKGZhbFxcLihhaXxydW4pKSQvLnRlc3QoaG9zdCk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgbGltaXQsIGxlYWRpbmcgPSBmYWxzZSkge1xuICAgIGxldCBsYXN0RnVuYztcbiAgICBsZXQgbGFzdFJhbjtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKCFsYXN0UmFuICYmIGxlYWRpbmcpIHtcbiAgICAgICAgICAgIGZ1bmMoLi4uYXJncyk7XG4gICAgICAgICAgICBsYXN0UmFuID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsYXN0RnVuYykge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChsYXN0RnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0RnVuYyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gbGFzdFJhbiA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0UmFuID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBsaW1pdCAtIChEYXRlLm5vdygpIC0gbGFzdFJhbikpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmxldCBpc1J1bm5pbmdJblJlYWN0O1xuLyoqXG4gKiBOb3QgcmVhbGx5IHRoZSBtb3N0IG9wdGltYWwgd2F5IHRvIGRldGVjdCBpZiB3ZSdyZSBydW5uaW5nIGluIFJlYWN0LFxuICogYnV0IHRoZSBpZGVhIGhlcmUgaXMgdGhhdCB3ZSBjYW4gc3VwcG9ydCBtdWx0aXBsZSByZW5kZXJpbmcgZW5naW5lc1xuICogKHN0YXJ0aW5nIHdpdGggUmVhY3QpLCB3aXRoIGFsbCB0aGVpciBwZWN1bGlhcml0aWVzLCB3aXRob3V0IGhhdmluZ1xuICogdG8gYWRkIGEgZGVwZW5kZW5jeSBvciBjcmVhdGluZyBjdXN0b20gaW50ZWdyYXRpb25zIChlLmcuIGN1c3RvbSBob29rcykuXG4gKlxuICogWWVzLCBhIGJpdCBvZiBtYWdpYyB0byBtYWtlIHRoaW5ncyB3b3JrcyBvdXQtb2YtdGhlLWJveC5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBydW5uaW5nIGluIFJlYWN0LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNSZWFjdCgpIHtcbiAgICBpZiAoaXNSdW5uaW5nSW5SZWFjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgIGlzUnVubmluZ0luUmVhY3QgPVxuICAgICAgICAgICAgISFzdGFjayAmJlxuICAgICAgICAgICAgICAgIChzdGFjay5pbmNsdWRlcyhcIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLmluY2x1ZGVzKFwibm9kZV9tb2R1bGVzL25leHQvXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzUnVubmluZ0luUmVhY3Q7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gc2xlZXAgZm9yIGEgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICovXG5mdW5jdGlvbiBzbGVlcChtcykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/utils.js\n");

/***/ })

};
;